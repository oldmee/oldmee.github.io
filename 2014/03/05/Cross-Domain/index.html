<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 跨域问题 · oldmee</title><meta name="description" content="跨域问题 - oldmee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://oldmee.github.io/atom.xml" title="oldmee"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="oldmee" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://blog.csdn.net/javaer_lee" target="_blank" class="nav-list-link">CSDN</a></li><li class="nav-list-item"><a href="https://github.com/oldmee" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">跨域问题</h1><div class="post-info">Mar 5, 2014</div><div class="post-content"><p>要解决跨域问题先来看看什么是同源策略。</p>
<span id="more"></span>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。</p>
<p>下表给出了相对<code><a target="_blank" rel="noopener" href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a></code>同源检测的示例:</p>
<p><img src="/images/crossDomain01.png"></p>
<h3 id="没有同源策略限制的两大危险场景"><a href="#没有同源策略限制的两大危险场景" class="headerlink" title="没有同源策略限制的两大危险场景"></a>没有同源策略限制的两大危险场景</h3><p>浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询。试想一下没有这样的限制上述两种动作有什么危险。</p>
<h4 id="没有同源策略限制的接口请求"><a href="#没有同源策略限制的接口请求" class="headerlink" title="没有同源策略限制的接口请求"></a>没有同源策略限制的接口请求</h4><p>有一个小小的东西叫cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景：</p>
<ol>
<li>你准备去清空你的购物车，于是打开了买买买网站，然后登录成功，一看，购物车东西这么少，不行，还得买多点。</li>
<li>你在看有什么东西买的过程中，你的好基友发给你一个链接，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。</li>
<li>你饶有兴致地浏览着，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向发起了请求！聪明的你一定想到上面的话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！如果这不是一个买买买账号，而是你的银行账号，那……</li>
</ol>
<p>这就是传说中的CSRF攻击浅谈CSRF攻击方式。</p>
<p>看了这波CSRF攻击我在想，即使有了同源策略限制，但cookie是明文的，还不是一样能拿下来。于是我看了一些cookie相关的文章聊一聊 cookie、Cookie&#x2F;Session的机制与安全，知道了服务端可以设置httpOnly，使得前端无法操作cookie，如果没有这样的设置，像XSS攻击就可以去获取到cookieWeb安全测试之XSS；设置secure，则保证在https的加密通信中传输以防截获。</p>
<h4 id="没有同源策略限制的Dom查询"><a href="#没有同源策略限制的Dom查询" class="headerlink" title="没有同源策略限制的Dom查询"></a>没有同源策略限制的Dom查询</h4><p>1.有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进去改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。<br>2.睡眼朦胧的你没看清楚，平时访问的银行网站是yinhang.com，而现在访问的是yinghang.com，这个钓鱼网站做了什么呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;iframe name=<span class="string">&quot;yinhang&quot;</span> src=<span class="string">&quot;www.yinhang.com&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="comment">// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom</span></span><br><span class="line"><span class="keyword">const</span> iframe = <span class="variable language_">window</span>.<span class="property">frames</span>[<span class="string">&#x27;yinhang&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> node = iframe.<span class="property">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;你输入账号密码的Input&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`拿到了这个<span class="subst">$&#123;node&#125;</span>，我还拿不到你刚刚输入的账号密码吗`</span>)</span><br></pre></td></tr></table></figure>
<p>由此我们知道，同源策略确实能规避一些危险，不是说有了同源策略就安全，只是说同源策略是一种浏览器最基本的安全机制，毕竟能提高一点攻击的成本。其实没有刺不穿的盾，只是攻击的成本和攻击成功后获得的利益成不成正比。</p>
<h3 id="同源策略限制下接口请求的正确打开方式"><a href="#同源策略限制下接口请求的正确打开方式" class="headerlink" title="同源策略限制下接口请求的正确打开方式"></a>同源策略限制下接口请求的正确打开方式</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。</p>
<p>服务端加上<code>Access-Control-Allow-Origin: *</code> 搞定。</p>
<h3 id="同源策略限制下Dom查询的正确打开方式"><a href="#同源策略限制下Dom查询的正确打开方式" class="headerlink" title="同源策略限制下Dom查询的正确打开方式"></a>同源策略限制下Dom查询的正确打开方式</h3><p>用这个，<code>window.postMessage()</code> 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2015/02/26/RPC/" class="prev">PREV</a><a href="/2014/03/04/atement-PreparedStatement/" class="next">NEXT</a></div><div class="copyright"><p>© 2012 - 2023 <a href="https://oldmee.github.io">oldmee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>