<!DOCTYPE html><html lang="en-us"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 使用 Protocol Buffers 代替 JSON 的五个原因 · oldmee</title><meta name="description" content="使用 Protocol Buffers 代替 JSON 的五个原因 - oldmee"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://oldmee.github.io/atom.xml" title="oldmee"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="oldmee" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://blog.csdn.net/javaer_lee" target="_blank" class="nav-list-link">CSDN</a></li><li class="nav-list-item"><a href="https://github.com/oldmee" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/me/" target="_self" class="nav-list-link">ME</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">使用 Protocol Buffers 代替 JSON 的五个原因</h1><div class="post-info">Feb 25, 2019</div><div class="post-content"><p><img src="/pb.png"></p>
<span id="more"></span>

<h3 id="原因一-模式本身很不错"><a href="#原因一-模式本身很不错" class="headerlink" title="原因一: 模式本身很不错"></a>原因一: 模式本身很不错</h3><p>有一种痛苦的讽刺指向一个事实，我们小心谨慎地在我们的数据库里面编写数据模型，维护各个层次的代码，保持这些数据模型处于控制之中，当我们想要发送数据连接到另一个服务的时候，要求所有的疑虑都要被考虑到。然而，我们往往依靠的是在边界上与我们的系统之间不一致的代码，我们的系统不能强制结构化我们的数据组件，这是如此的重要，编码的语义是你曾经的业务对象，在proto格式中，它足以帮助并保证应用程序之间的信号不会丢失，而界限就在你所创建并执行的业务规则。</p>
<h3 id="原因二-无偿地向后兼容"><a href="#原因二-无偿地向后兼容" class="headerlink" title="原因二: 无偿地向后兼容"></a>原因二: 无偿地向后兼容</h3><p>被编号的字段在proto的定义中排除了所需的版本检查，这是其中一个被明确表述的动机（为什么这样设计和实现Protocol Buffers）。如同开发者文档中声明的那样，协议被设计成能在一定程度上避免出现像下面这样的“丑陋的代码”，下面的代码用来检测协议的版本:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (version == <span class="number">3</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (version == <span class="number">5</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同编号字段一样, 你必须改变编码习惯，朝着能向老版本维护和向后兼容的方向改变。正如在文档中的声明那样，曾经 Protocol Buffers 是这样被介绍的：</p>
<p>“新的字段可以很容易被引入，并且不需要中间服务去检查数据就能被解析，通过数据不必知道所有的字段。”</p>
<p>已经部署各种JSON的服务器已经遭受各种与发展模式以及向后兼容的相关问题。我现在深信编号字段能防止错误，并且能在新功能和服务的推出上做到简化。</p>
<h3 id="原因三-更少的样本代码"><a href="#原因三-更少的样本代码" class="headerlink" title="原因三: 更少的样本代码"></a>原因三: 更少的样本代码</h3><p>除了显式的版本检查和缺乏后续的兼容性，JSON终端在HTTP上的基础服务通常依赖专门的手写样板代码去处理Ruby对象的编码和解码。解析和反解析类常常包含隐藏的业务逻辑，它暴露了手动解析每个新的数据类型的缺陷，当一个类通过Protocol Buffers产生（你一般就不会再去触碰它），它能提供大量相似的方法，还避免了大量头痛的事情。随着模式的发展，你将会用proto产生类（应当承认，一旦你更新他们），你可以把更多的空间留给你所关注的挑战（保持你的应用运行和持续构建产品）。</p>
<h3 id="原因四-验证和可扩展性"><a href="#原因四-验证和可扩展性" class="headerlink" title="原因四: 验证和可扩展性"></a>原因四: 验证和可扩展性</h3><p>required，optional 和 repeated关键字在Protocol Buffers中的定义是非常强大的。它们允许你去编码，在模式级别，形象化你的数据结构和去实现类怎样工作（每种编程语言处理）的细节。Ruby的protocol_buffers库将会提升异常，例如：如果一个对象实例没有填写必填的字段，你试着去对这样一个对象实例编码，就会提升异常。通过简单地编辑一个新的编号字段的值，你可以把一个字段从required变成optional或者反之亦然。有了这种灵活编码的语义序列化格式，大大增强了其功能。</p>
<p>因为你还可以嵌入proto，定义内部的其他成员，你也可以拥有通用的Request和Response结构，它还允许其他数据结构的传输并确保传输连接上，它为服务器间通讯实现真正的灵活性和安全的数据传输提供了机会。类似Riak的数据库系统使用Protocol Buffers有巨大的效果——因为有了一些启示，我建议重新审视那些接口。</p>
<h3 id="原因五：建议的语言互操作性"><a href="#原因五：建议的语言互操作性" class="headerlink" title="原因五：建议的语言互操作性"></a>原因五：建议的语言互操作性</h3><p>因为Protocol Buffers已经被多种语言实现，在你的架构中多语言混合的应用程序之间的互操作性变得更简单。如果你引入了一个新的服务在JAVA或者GO中，甚至和用Node或者Clojure或者Scala实现的后端通讯，你只需简单的把proto文件交给目标语言编写的代码生成器，你将在这些架构之间获得较好的安全和互操作性。平台特定数据类型的细节被目标语言处理，你将更多的关注你的问题的困难部分，而不是匹配字段和数据类型在JSON的编码和解码方案中。</p>
<br/>

<h3 id="什么时候更适合使用JSON"><a href="#什么时候更适合使用JSON" class="headerlink" title="什么时候更适合使用JSON?"></a>什么时候更适合使用JSON?</h3><p>有些时候JSON比Protocol Buffers更适合，包括如下的场景：</p>
<ul>
<li>你需要或者想让数据对人是可读的</li>
<li>来自于服务的数据是直接发送到web浏览器</li>
<li>你的服务端应用程序是用javaScript编写的</li>
<li>你不准备把数据模型绑定到模式上</li>
<li>你没有带宽添加另外一个工具到你的军火库</li>
<li>运行不同类型的网络服务的运营负担过大</li>
</ul>
<p>可能还有更多的情况。最后，总之，这是很重要的在心里权衡和不要盲目的选择一项技术。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Protocol Buffers提供了几种相对JSON在内部服务之间在线传输数据的引人注目的优势。并没有完全的替换JSON，特别是服务和web浏览器直接通讯的情况，Protocol Buffers提供了真正的优势不仅在上面概述的方法，在编解码的速度和数据大小上有更多的优势。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/02/25/hexo-bugs-000/" class="prev">PREV</a><a href="/2019/02/25/deterministic-finite-automaton/" class="next">NEXT</a></div><div class="copyright"><p>© 2012 - 2023 <a href="https://oldmee.github.io">oldmee</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>