<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oldmee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oldmee.github.io/"/>
  <updated>2019-03-14T02:10:35.504Z</updated>
  <id>https://oldmee.github.io/</id>
  
  <author>
    <name>oldmee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>王者人机模式有Bug</title>
    <link href="https://oldmee.github.io/2019/03/14/KPL-BUG/"/>
    <id>https://oldmee.github.io/2019/03/14/KPL-BUG/</id>
    <published>2019-03-14T02:00:29.000Z</published>
    <updated>2019-03-14T02:10:35.504Z</updated>
    
    <content type="html"><![CDATA[<p>用米莱迪站在对面水晶与高地塔之间的安全区机器人是看不见的，然后用米莱迪的技能慢慢的把对方的水晶推掉，其他人守塔就行，要赶紧，估计版本更新这个bug也就修复了，那时候再要过人机20级可就难喽~<br><a id="more"></a></p><p><img src="/2019/03/14/KPL-BUG/kpl_1.jpg" alt></p><p><img src="/2019/03/14/KPL-BUG/kpl_2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用米莱迪站在对面水晶与高地塔之间的安全区机器人是看不见的，然后用米莱迪的技能慢慢的把对方的水晶推掉，其他人守塔就行，要赶紧，估计版本更新这个bug也就修复了，那时候再要过人机20级可就难喽~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://oldmee.github.io/2019/02/26/chain-of-responsibility-pattern/"/>
    <id>https://oldmee.github.io/2019/02/26/chain-of-responsibility-pattern/</id>
    <published>2019-02-25T16:01:24.000Z</published>
    <updated>2019-02-26T01:32:07.811Z</updated>
    
    <content type="html"><![CDATA[<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br><a id="more"></a><br>应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p><p>责任链模式demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">AbstractLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ConsoleLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"Standard Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ErrorLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"File::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ChainPatternDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">      AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">      AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"> </span><br><span class="line">      errorLogger.setNextLogger(fileLogger);</span><br><span class="line">      fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> errorLogger;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, </span><br><span class="line">         <span class="string">"This is an information."</span>);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </span><br><span class="line">         <span class="string">"This is an debug level information."</span>);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </span><br><span class="line">         <span class="string">"This is an error information."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Standard Console::Logger: This is an information.</span><br><span class="line">File::Logger: This is an debug level information.</span><br><span class="line">Standard Console::Logger: This is an debug level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">File::Logger: This is an error information.</span><br><span class="line">Standard Console::Logger: This is an error information.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最高级别的error会被输出三次，最低级别的info只会输出一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo-bugs-000</title>
    <link href="https://oldmee.github.io/2019/02/25/hexo-bugs-000/"/>
    <id>https://oldmee.github.io/2019/02/25/hexo-bugs-000/</id>
    <published>2019-02-25T12:04:00.000Z</published>
    <updated>2019-02-26T01:32:07.812Z</updated>
    
    <content type="html"><![CDATA[<p>在hexo本地服务器模式下，一旦文章内容过多（具体没测试，可以多放些内容试试），则生成的html在本地就会出问题，没有上一页下一页以及脚标信息，在浏览器里查看网页源代码发现都是些小方格，不知道是什么鬼。但是用户不知道啊，我搞了半天，发现原来是个bug，部署到github上一切正常，真的是脑壳痛……<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在hexo本地服务器模式下，一旦文章内容过多（具体没测试，可以多放些内容试试），则生成的html在本地就会出问题，没有上一页下一页以及脚标信息，在浏览器里查看网页源代码发现都是些小方格，不知道是什么鬼。但是用户不知道啊，我搞了半天，发现原来是个bug，部署到github上一切正常，真的是脑壳痛……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="bugs" scheme="https://oldmee.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>使用 Protocol Buffers 代替 JSON 的五个原因</title>
    <link href="https://oldmee.github.io/2019/02/25/protocol-buffers/"/>
    <id>https://oldmee.github.io/2019/02/25/protocol-buffers/</id>
    <published>2019-02-25T09:53:25.000Z</published>
    <updated>2019-02-26T01:32:07.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/25/protocol-buffers/pb.png" alt><br><a id="more"></a></p><h3 id="原因一-模式本身很不错"><a href="#原因一-模式本身很不错" class="headerlink" title="原因一: 模式本身很不错"></a>原因一: 模式本身很不错</h3><p>有一种痛苦的讽刺指向一个事实，我们小心谨慎地在我们的数据库里面编写数据模型，维护各个层次的代码，保持这些数据模型处于控制之中，当我们想要发送数据连接到另一个服务的时候，要求所有的疑虑都要被考虑到。然而，我们往往依靠的是在边界上与我们的系统之间不一致的代码，我们的系统不能强制结构化我们的数据组件，这是如此的重要，编码的语义是你曾经的业务对象，在proto格式中，它足以帮助并保证应用程序之间的信号不会丢失，而界限就在你所创建并执行的业务规则。</p><h3 id="原因二-无偿地向后兼容"><a href="#原因二-无偿地向后兼容" class="headerlink" title="原因二: 无偿地向后兼容"></a>原因二: 无偿地向后兼容</h3><p>被编号的字段在proto的定义中排除了所需的版本检查，这是其中一个被明确表述的动机（为什么这样设计和实现Protocol Buffers）。如同开发者文档中声明的那样，协议被设计成能在一定程度上避免出现像下面这样的“丑陋的代码”，下面的代码用来检测协议的版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (version == <span class="number">3</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (version == <span class="number">5</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同编号字段一样, 你必须改变编码习惯，朝着能向老版本维护和向后兼容的方向改变。正如在文档中的声明那样，曾经 Protocol Buffers 是这样被介绍的：</p><p>“新的字段可以很容易被引入，并且不需要中间服务去检查数据就能被解析，通过数据不必知道所有的字段。”</p><p>已经部署各种JSON的服务器已经遭受各种与发展模式以及向后兼容的相关问题。我现在深信编号字段能防止错误，并且能在新功能和服务的推出上做到简化。</p><h3 id="原因三-更少的样本代码"><a href="#原因三-更少的样本代码" class="headerlink" title="原因三: 更少的样本代码"></a>原因三: 更少的样本代码</h3><p>除了显式的版本检查和缺乏后续的兼容性，JSON终端在HTTP上的基础服务通常依赖专门的手写样板代码去处理Ruby对象的编码和解码。解析和反解析类常常包含隐藏的业务逻辑，它暴露了手动解析每个新的数据类型的缺陷，当一个类通过Protocol Buffers产生（你一般就不会再去触碰它），它能提供大量相似的方法，还避免了大量头痛的事情。随着模式的发展，你将会用proto产生类（应当承认，一旦你更新他们），你可以把更多的空间留给你所关注的挑战（保持你的应用运行和持续构建产品）。</p><h3 id="原因四-验证和可扩展性"><a href="#原因四-验证和可扩展性" class="headerlink" title="原因四: 验证和可扩展性"></a>原因四: 验证和可扩展性</h3><p>required，optional 和 repeated关键字在Protocol Buffers中的定义是非常强大的。它们允许你去编码，在模式级别，形象化你的数据结构和去实现类怎样工作（每种编程语言处理）的细节。Ruby的protocol_buffers库将会提升异常，例如：如果一个对象实例没有填写必填的字段，你试着去对这样一个对象实例编码，就会提升异常。通过简单地编辑一个新的编号字段的值，你可以把一个字段从required变成optional或者反之亦然。有了这种灵活编码的语义序列化格式，大大增强了其功能。</p><p>因为你还可以嵌入proto，定义内部的其他成员，你也可以拥有通用的Request和Response结构，它还允许其他数据结构的传输并确保传输连接上，它为服务器间通讯实现真正的灵活性和安全的数据传输提供了机会。类似Riak的数据库系统使用Protocol Buffers有巨大的效果——因为有了一些启示，我建议重新审视那些接口。</p><h3 id="原因五：建议的语言互操作性"><a href="#原因五：建议的语言互操作性" class="headerlink" title="原因五：建议的语言互操作性"></a>原因五：建议的语言互操作性</h3><p>因为Protocol Buffers已经被多种语言实现，在你的架构中多语言混合的应用程序之间的互操作性变得更简单。如果你引入了一个新的服务在JAVA或者GO中，甚至和用Node或者Clojure或者Scala实现的后端通讯，你只需简单的把proto文件交给目标语言编写的代码生成器，你将在这些架构之间获得较好的安全和互操作性。平台特定数据类型的细节被目标语言处理，你将更多的关注你的问题的困难部分，而不是匹配字段和数据类型在JSON的编码和解码方案中。</p><p><br></p><h3 id="什么时候更适合使用JSON"><a href="#什么时候更适合使用JSON" class="headerlink" title="什么时候更适合使用JSON?"></a>什么时候更适合使用JSON?</h3><p>有些时候JSON比Protocol Buffers更适合，包括如下的场景：</p><ul><li>你需要或者想让数据对人是可读的</li><li>来自于服务的数据是直接发送到web浏览器</li><li>你的服务端应用程序是用javaScript编写的</li><li>你不准备把数据模型绑定到模式上</li><li>你没有带宽添加另外一个工具到你的军火库</li><li>运行不同类型的网络服务的运营负担过大</li></ul><p>可能还有更多的情况。最后，总之，这是很重要的在心里权衡和不要盲目的选择一项技术。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Protocol Buffers提供了几种相对JSON在内部服务之间在线传输数据的引人注目的优势。并没有完全的替换JSON，特别是服务和web浏览器直接通讯的情况，Protocol Buffers提供了真正的优势不仅在上面概述的方法，在编解码的速度和数据大小上有更多的优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/02/25/protocol-buffers/pb.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>敏感词过滤算法</title>
    <link href="https://oldmee.github.io/2019/02/25/deterministic-finite-automaton/"/>
    <id>https://oldmee.github.io/2019/02/25/deterministic-finite-automaton/</id>
    <published>2019-02-25T07:09:58.000Z</published>
    <updated>2019-02-25T07:27:50.213Z</updated>
    
    <content type="html"><![CDATA[<p>在实现文字过滤的算法中，DFA是唯一比较好的实现算法。DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。<br><a id="more"></a><br>敏感词会被构建成状态加标志位的形式，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 读取敏感词库，将敏感词放入HashSet中，构建一个DFA算法模型：&lt;br&gt; </span></span><br><span class="line"><span class="comment">     * 中 = &#123; </span></span><br><span class="line"><span class="comment">     *      isEnd = 0 </span></span><br><span class="line"><span class="comment">     *      国 = &#123; </span></span><br><span class="line"><span class="comment">     *           isEnd = 1 </span></span><br><span class="line"><span class="comment">     *           人 = &#123;isEnd = 0 </span></span><br><span class="line"><span class="comment">     *                民 = &#123;isEnd = 1&#125; </span></span><br><span class="line"><span class="comment">     *                &#125; </span></span><br><span class="line"><span class="comment">     *           男  = &#123; </span></span><br><span class="line"><span class="comment">     *                  isEnd = 0 </span></span><br><span class="line"><span class="comment">     *                   人 = &#123; </span></span><br><span class="line"><span class="comment">     *                        isEnd = 1 </span></span><br><span class="line"><span class="comment">     *                       &#125; </span></span><br><span class="line"><span class="comment">     *               &#125; </span></span><br><span class="line"><span class="comment">     *           &#125; </span></span><br><span class="line"><span class="comment">     *      &#125; </span></span><br><span class="line"><span class="comment">     *  五 = &#123; </span></span><br><span class="line"><span class="comment">     *      isEnd = 0 </span></span><br><span class="line"><span class="comment">     *      星 = &#123; </span></span><br><span class="line"><span class="comment">     *          isEnd = 0 </span></span><br><span class="line"><span class="comment">     *          红 = &#123; </span></span><br><span class="line"><span class="comment">     *              isEnd = 0 </span></span><br><span class="line"><span class="comment">     *              旗 = &#123; </span></span><br><span class="line"><span class="comment">     *                   isEnd = 1 </span></span><br><span class="line"><span class="comment">     *                  &#125; </span></span><br><span class="line"><span class="comment">     *              &#125; </span></span><br><span class="line"><span class="comment">     *          &#125; </span></span><br><span class="line"><span class="comment">     *      &#125; </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> null  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019年2月25日 下午3:04:20 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyWordSet  敏感词库 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@version</span> 1.0 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实现文字过滤的算法中，DFA是唯一比较好的实现算法。DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何设计一个高并发系统</title>
    <link href="https://oldmee.github.io/2019/02/25/design-high-concurrency-system/"/>
    <id>https://oldmee.github.io/2019/02/25/design-high-concurrency-system/</id>
    <published>2019-02-25T04:39:57.000Z</published>
    <updated>2019-02-25T07:28:36.364Z</updated>
    
    <content type="html"><![CDATA[<p>有过高并发实践经验的当然最好了，但事实是这很难，除非是这家公司是匹黑马，你刚去的时候用户不多，但是行业发展好，每月几百万用户用户的增长，你不断的踩坑，不断地升级公司的系统架构，现在不太可能实现了，互联网巨头们都已经尘埃落定，所以大部分人基本上也碰不到这些个情况了，但是互联网公司面试要问呐，咋整？<br><a id="more"></a><br>第一类当然是最好的，有过经验的，没有怎么办？退而求其次！你没吃过猪肉还没见过猪跑？把理论玩精了，总比对高并发系统一无所知的人要好的多吧。</p><p>如果你属于第二种情况，试试从下面六个方面来设计一个高并发的系统：</p><ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><img src="/2019/02/25/design-high-concurrency-system/hc.jpg" alt></p><h3 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h3><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><blockquote><p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p><footer><strong>--很现实但没什么意义的话</strong></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有过高并发实践经验的当然最好了，但事实是这很难，除非是这家公司是匹黑马，你刚去的时候用户不多，但是行业发展好，每月几百万用户用户的增长，你不断的踩坑，不断地升级公司的系统架构，现在不太可能实现了，互联网巨头们都已经尘埃落定，所以大部分人基本上也碰不到这些个情况了，但是互联网公司面试要问呐，咋整？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图书列表清单</title>
    <link href="https://oldmee.github.io/2019/02/25/book-list/"/>
    <id>https://oldmee.github.io/2019/02/25/book-list/</id>
    <published>2019-02-25T01:29:22.000Z</published>
    <updated>2019-02-25T07:31:04.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>老话说的好：少打王者多读书。</p></blockquote><a id="more"></a><h3 id="阅读清单"><a href="#阅读清单" class="headerlink" title="阅读清单"></a>阅读清单</h3><blockquote><p>2018-12-08<br>第一批次</p></blockquote><ul><li>Java编程思想 第4版</li><li>Head First 设计模式</li><li>深入理解Java虚拟机 JVM高级特性与最佳实践</li><li>Effective Java英文版 第三版</li><li>重构 改善既有代码的设计</li><li>Docker技术入门与实战</li><li>Hadoop权威指南第四版</li><li>Hive编程指南</li><li>Spark快速大数据分析<br><br></li></ul><blockquote><p>2019-01-24<br>第二批次</p></blockquote><ul><li>Effective Java中文版 第三版<br><br></li></ul><blockquote><p>2019-02-20<br>第三批次</p></blockquote><ul><li>RocketMQ技术内幕</li><li>企业私有云建设指南</li><li>ZooKeeper分布式过程协同技术详解</li><li>架构即未来</li><li>架构真经</li><li>Java机器学习</li></ul><p>…未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;老话说的好：少打王者多读书。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按键精灵编码最佳实践</title>
    <link href="https://oldmee.github.io/2019/02/22/tsy-coding-best-practice/"/>
    <id>https://oldmee.github.io/2019/02/22/tsy-coding-best-practice/</id>
    <published>2019-02-22T08:08:55.000Z</published>
    <updated>2019-03-13T07:33:16.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总来来说就是一次循环就执行一个动作，代码按照界面来操作（到了这个界面应该做什么动作）<br>遵循这个理论下面是具体的执行标准</p></blockquote><a id="more"></a><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><ul><li>用else if代替单条if</li><li>每条else if代表一个界面</li></ul><h3 id="Debug技巧"><a href="#Debug技巧" class="headerlink" title="Debug技巧"></a>Debug技巧</h3><ul><li>刚修改的地方全部注释，缩小范围</li><li>注释一整段if语句，缩小范围</li></ul><h3 id="取色技巧"><a href="#取色技巧" class="headerlink" title="取色技巧"></a>取色技巧</h3><ul><li>找点的时候不要去找阴影区域的点</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;总来来说就是一次循环就执行一个动作，代码按照界面来操作（到了这个界面应该做什么动作）&lt;br&gt;遵循这个理论下面是具体的执行标准&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo Admin的使用</title>
    <link href="https://oldmee.github.io/2019/02/22/hexo-use/"/>
    <id>https://oldmee.github.io/2019/02/22/hexo-use/</id>
    <published>2019-02-22T03:22:00.000Z</published>
    <updated>2019-02-25T07:31:21.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是一个坑"><a href="#这是一个坑" class="headerlink" title="这是一个坑"></a>这是一个坑</h3><p>安装方式我就不说了，就是按照网上说的那样，我主要说一下Deploy中的脚本怎么配置，网上都是类似这种<br><a id="more"></a><br><blockquote><p>./xxxx.sh</p></blockquote></p><p>完了我也傻不拉几的按照这种方式写，后来发现这就是一个脚本，你不用deploy就用命令行运行也是一样的，<br>admin只是一个写markdown的工具，部署只是提供给你一个快捷键罢了，问题是我是Windows，居然也用.sh真是尴尬，改成.bat路径前面也不需要.这也是linux下的写法。deployCommand: ‘hexo-generate.bat’ 就行了。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>每次hexo deploy的时候是不是都要输入github用户名密码？<br>可以这样做</p><p>先配置一个环境变量</p><p><img src="/2019/02/22/hexo-use/home.png" style="margin-left:0px"></p><p>接着在你的用户目录（C:\Users\username）下新建一个叫 _netrc的文件(没有拓展名)<br>编辑这个文件</p><ul><li>machine github.com</li><li>login username</li><li>password password</li></ul><p>设置好这些后，当你再次部署时，就不用输入用户名和密码了。</p><h3 id="tips2"><a href="#tips2" class="headerlink" title="tips2"></a>tips2</h3><p>hexo admin可以配置用户名和密码，密码需要用bcrypt加密，方法如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BCryptDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 　　<span class="comment">// Hash a password for the first time</span></span><br><span class="line"> 　　　　String password = <span class="string">"testpassword"</span>;</span><br><span class="line">　　　　String hashed = BCrypt.hashpw(password, BCrypt.gensalt());</span><br><span class="line">　　　　System.out.println(hashed);</span><br><span class="line">　　<span class="comment">// gensalt's log_rounds parameter determines the complexity</span></span><br><span class="line">　　<span class="comment">// the work factor is 2**log_rounds, and the default is 10</span></span><br><span class="line">　　String hashed2 = BCrypt.hashpw(password, BCrypt.gensalt(<span class="number">12</span>));</span><br><span class="line"> </span><br><span class="line">　　<span class="comment">// Check that an unencrypted password matches one that has</span></span><br><span class="line">　　<span class="comment">// previously been hashed</span></span><br><span class="line">　　String candidate = <span class="string">"testpassword"</span>;</span><br><span class="line">　　<span class="comment">//String candidate = "wrongtestpassword";</span></span><br><span class="line">　　<span class="keyword">if</span> (BCrypt.checkpw(candidate, hashed))</span><br><span class="line">　　　　System.out.println(<span class="string">"It matches"</span>);</span><br><span class="line">　　<span class="keyword">else</span></span><br><span class="line">　　System.out.println(<span class="string">"It does not match"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这是一个坑&quot;&gt;&lt;a href=&quot;#这是一个坑&quot; class=&quot;headerlink&quot; title=&quot;这是一个坑&quot;&gt;&lt;/a&gt;这是一个坑&lt;/h3&gt;&lt;p&gt;安装方式我就不说了，就是按照网上说的那样，我主要说一下Deploy中的脚本怎么配置，网上都是类似这种&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo使用" scheme="https://oldmee.github.io/categories/hexo%E4%BD%BF%E7%94%A8/"/>
    
      <category term="hexo admin" scheme="https://oldmee.github.io/categories/hexo%E4%BD%BF%E7%94%A8/hexo-admin/"/>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="博客" scheme="https://oldmee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Class.forName(&quot;jdbc地址&quot;)到底在干啥</title>
    <link href="https://oldmee.github.io/2019/02/21/mysql-jdbc-driver-function/"/>
    <id>https://oldmee.github.io/2019/02/21/mysql-jdbc-driver-function/</id>
    <published>2019-02-21T04:56:51.000Z</published>
    <updated>2019-03-04T02:33:23.978Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/21/mysql-jdbc-driver-function/mysql.jpg" alt></p><blockquote><p>Talk is cheap，show me the code.</p><footer><strong>--老李</strong></footer></blockquote><a id="more"></a><p>Class.forName(“com.mysql.jdbc.Driver”).newInstance() （Java 9开始newInstance()就已经不赞成使用了）<br>等价于com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();</p><p>Class.forName()的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段（并没有创建新对象）</p><p>所以也可以这么写：com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();</p><p>再看看Driver的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mysql.jdbc</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="comment">// --------------------------------------------- //</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ~ Constructors   </span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据下面三条规则：</p><p>1.当调用一个类的静态变量时，这个类中的静态代码块会执行。【只有静态代码块会执行】</p><p>2.当调用一个 类的静态方法时，这个类中的静态代码块会执行。【只有静态代码块会执行】</p><p>3.当创建一个 类的一个实例时，这个类中的静态代码块、非静态代码块（也叫构造代码块）、创建实例的相应的构造方法都会执行。</p><p>什么？还不明白？</p><p>Class.forName(“com.mysql.jdbc.Driver”);<br>String url = “jdbc:mysql://127.0.0.1/test?useUnicode=true&amp;characterEncoding=utf-8”;<br>String user = “”;<br>String psw = “”;<br>Connection con = DriverManager.getConnection(url,user,psw);<br>Class.forName就是触发static代码块中driver注册到DriverManager的行为，注册完了就可以随便调用了呗。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>JDBC还用到了桥接模式，从上面的源码中也很容易理解，数据库厂家安心开发自己的实现，不论是MySQL还是Oracle，通过DriverManager统一进行注册绑定。</p><p>再次理解一下桥接的定义：<br>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/02/21/mysql-jdbc-driver-function/mysql.jpg&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Talk is cheap，show me the code.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;--老李&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>我的半生感悟</title>
    <link href="https://oldmee.github.io/2019/02/12/myLife/"/>
    <id>https://oldmee.github.io/2019/02/12/myLife/</id>
    <published>2019-02-12T02:09:00.000Z</published>
    <updated>2019-02-25T11:00:17.218Z</updated>
    
    <content type="html"><![CDATA[<p>学平上了年纪，有很多话要说……<br><a id="more"></a></p><h3 id="中年"><a href="#中年" class="headerlink" title="中年"></a>中年</h3><p>人到中年，有很多想法，也有很多困惑，今天是2019年第一天上班，本来说要昨天做个总结的，但是昨天不知道干嘛了，这个总结也是昨天突然想写的，今天补上吧（其实平时有很多想法都是灵光一闪，想记录着的，但是就是没记）。</p><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><p>关于家庭，感觉自己就像处在沼泽中在使劲挣扎着，特别不想动，累吗？好像也不是特别累，但就是不想动，又不得不动，给自己下个总结，就是人懒但是现在已经不是一个人了，拖家带口的，还得照顾家庭，所以还得挣扎，但是很不情愿，不情愿也没办法，人活在世总得担责任嘛。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>关于工作，越来越觉得上班是一件性价比极低的事情，在杭州干软件可能年薪二十到三十万就是一个坎了，往上升的途径应该很窄（我说的的大概率情况，开挂的情况不在我说的范围内，因为我就是一个普通的不能再普通的人了，没有幻想着开挂也没有幻想中500万大奖），把我未来的黄金10年重心都放在工作上，想想就可惜，主要是上班工作本质上是拿时间换钱，一种等价交换，时间没了就换不回钱了，不可能有任何积累，没有积累就不会有延续，就像买了瓶汽水喝完就没了，现在满脑子想的是怎么打造一个赚钱的机器，有了机器会轻松很多，虽然需要时不时的去维护一下，但是机器可以传承延续啊，还可以再打造别的机器啊，这样的人生岂不是更有趣一些，当然想法是美好的现实是残酷的，实现这个想法的前提是要有基本的生活保障，突然想人要是不吃饭，光靠光合作用就能活下去多好。</p><h3 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h3><p>关于困惑，有时候幻想自己已经不再为衣食住行发愁了，我下一步要干啥呢，每天看看电影，世界各地走走？嗯，刚开始可能还新鲜，但是3年以后，5年以后呢，一直这样吗，那多无聊啊，看新闻说郭涛15岁看了终结者后就想拍一部自己的科幻电影，直到今年流浪地球拍出来了，过程当然比较坎坷，但是梦想还是实现了，关于困惑我想说的是我就好像没有啥特别爱好，这是我比较困惑的地方，高晓松说，40不惑就是40岁以后不是没有惑了，而是40岁以后想不明白事就不去想了。我不知道我15岁想要啥，但是我知道我12岁想要啥，为啥是12岁呢，因为一轮生肖都走了一圈，那天家里给买了个大蛋糕还许了愿，当时许的愿就是能有一台打游戏的vcd，因为当时有个广告天天播，又能打游戏又能看电影的一台机器，一想到又能打游戏又能看电影真好，所以就许了这么一个愿望，虽然后来没得到这么一台机器，但是后来上大学我有了电脑啊，大概10年，这也算是愿望实现了吧。</p><h3 id="买房"><a href="#买房" class="headerlink" title="买房"></a>买房</h3><p>关于买房，12岁以后就没有什么特别大的愿望了，甚至大学里都没有什么想法，直到毕业后刚上班有工资了后就是特别想攒一笔10万人民币，当时也没想着拿这10万去干啥干啥，就想着有个目标呗，毕业也快10年了，这10万具体是啥时候攒起来不记得了，只记得15年年底已经到处跑着看房子了，当时也没想着买，就是看看，现在想想15年好像已经有10万了，但是离买的起还差20万，所以只是看看，想得是还得攒2年钱，结果16年9月份G20之后房价像火箭一样，之前看过的房17年10月份再挨个问过去房价都翻倍了，安安心心攒了一年钱，再去看的时候傻眼了，买房一下子提上日程了，看了一圈后，发现要想买房，必须降低自己原来的期望值（原来看的都是100坪左右的，小区环境比较好的），16年底看中的一套105平方2手房，首付加各种费35万拿不出来，最后只好作罢，直到17年3月份36万首付买了80个平的二手，真是一路的心酸，通过这次买房一下打破了固有思维（一直想一步到位然后住一辈子，现在不这么想了，现在想的是多大能力办多大事，而且房子过10年后开始变旧，而新的格局更好的产品也会开发出来），以后就是想着隔10年换一次房（卖旧买新）。 </p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>一些感悟，每个人都有瓶颈，上升到一定阶段后很难突破，就像父辈一样，他们已经完成了他们的使命，而我现在来到了瓶颈地，延续老的思维已经很难上升了，该想着怎么打破现状继续前行，如果打不破，我现在的状态就是下一代的起点。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>关于未来，生活还要继续。。。</p><p>by 花蝴蝶</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学平上了年纪，有很多话要说……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人生" scheme="https://oldmee.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to JSON Web Tokens</title>
    <link href="https://oldmee.github.io/2018/12/10/JSON-Web-Token/"/>
    <id>https://oldmee.github.io/2018/12/10/JSON-Web-Token/</id>
    <published>2018-12-10T01:53:00.000Z</published>
    <updated>2019-03-08T03:21:54.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What-is-JSON-Web-Token"><a href="#What-is-JSON-Web-Token" class="headerlink" title="What is JSON Web Token?"></a>What is JSON Web Token?</h3><p>JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the <strong>HMAC</strong> algorithm) or a public/private key pair using <strong>RSA</strong> or <strong>ECDSA</strong>.<br><a id="more"></a><br>Although JWTs can be encrypted to also provide secrecy between parties, we will focus on signed tokens. Signed tokens can verify the integrity of the claims contained within it, while encrypted tokens hide those claims from other parties. When tokens are signed using public/private key pairs, the signature also certifies that only the party holding the private key is the one that signed it.</p><h3 id="When-should-you-use-JSON-Web-Tokens"><a href="#When-should-you-use-JSON-Web-Tokens" class="headerlink" title="When should you use JSON Web Tokens?"></a>When should you use JSON Web Tokens?</h3><p>Here are some scenarios where JSON Web Tokens are useful:</p><ul><li><p>Authorization: This is the most common scenario for using JWT. Once the user is logged in, each subsequent request will include the JWT, allowing the user to access routes, services, and resources that are permitted with that token. Single Sign On is a feature that widely uses JWT nowadays, because of its small overhead and its ability to be easily used across different domains.</p></li><li><p>Information Exchange: JSON Web Tokens are a good way of securely transmitting information between parties. Because JWTs can be signed—for example, using public/private key pairs—you can be sure the senders are who they say they are. Additionally, as the signature is calculated using the header and the payload, you can also verify that the content hasn’t been tampered with.</p></li></ul><h3 id="What-is-the-JSON-Web-Token-structure"><a href="#What-is-the-JSON-Web-Token-structure" class="headerlink" title="What is the JSON Web Token structure?"></a>What is the JSON Web Token structure?</h3><p>In its compact form, JSON Web Tokens consist of three parts separated by dots (.), which are:</p><ul><li>Header</li><li>Payload</li><li>Signature</li></ul><p>Therefore, a JWT typically looks like the following.</p><p>xxxxx.yyyyy.zzzzz</p><p>Let’s break down the different parts.</p><h4 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h4><p>The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA.</p><p>For example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then, this JSON is Base64Url encoded to form the first part of the JWT.</p><h4 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h4><p>The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims.</p><ul><li><p>Registered claims: These are a set of predefined claims which are not mandatory but recommended, to provide a set of useful, interoperable claims. Some of them are: iss (issuer), exp (expiration time), sub (subject), aud (audience), and others.</p><p>Notice that the claim names are only three characters long as JWT is meant to be compact.</p></li><li><p>Public claims: These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace.</p></li><li><p>Private claims: These are the custom claims created to share information between parties that agree on using them and are neither registered or public claims.</p></li></ul><p>An example payload could be:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>The payload is then <strong>Base64Url</strong> encoded to form the second part of the JSON Web Token.</p><p>Do note that for signed tokens this information, though protected against tampering, is readable by anyone. Do not put secret information in the payload or header elements of a JWT unless it is encrypted.</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.</p><p>For example if you want to use the HMAC SHA256 algorithm, the signature will be created in the following way:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><br>The signature is used to verify the message wasn’t changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is.</p><h4 id="Putting-all-together"><a href="#Putting-all-together" class="headerlink" title="Putting all together"></a>Putting all together</h4><p>The output is three Base64-URL strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML.</p><p>The following shows a JWT that has the previous header and payload encoded, and it is signed with a secret. </p><p><img src="/2018/12/10/JSON-Web-Token/jwt.png" alt></p><p>If you want to play with JWT and put these concepts into practice, you can use jwt.io Debugger to decode, verify, and generate JWTs.<br><img src="/2018/12/10/JSON-Web-Token/jwt2.png" alt></p><h3 id="How-do-JSON-Web-Tokens-work"><a href="#How-do-JSON-Web-Tokens-work" class="headerlink" title="How do JSON Web Tokens work?"></a>How do JSON Web Tokens work?</h3><p>In authentication, when the user successfully logs in using their credentials, a JSON Web Token will be returned. Since tokens are credentials, great care must be taken to prevent security issues. In general, you should not keep tokens longer than required.</p><p>Whenever the user wants to access a protected route or resource, the user agent should send the JWT, typically in the Authorization header using the Bearer schema. The content of the header should look like the following:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>This can be, in certain cases, a stateless authorization mechanism. The server’s protected routes will check for a valid JWT in the <code>Authorization</code> header, and if it’s present, the user will be allowed to access protected resources. If the JWT contains the necessary data, the need to query the database for certain operations may be reduced, though this may not always be the case.</p><p>If the token is sent in the <code>Authorization</code> header, Cross-Origin Resource Sharing (CORS) won’t be an issue as it doesn’t use cookies.</p><p>The following diagram shows how a JWT is obtained and used to access APIs or resources:</p><p><img src="/2018/12/10/JSON-Web-Token/jwt3.png" alt></p><ol><li>The application or client requests authorization to the authorization server. This is performed through one of the different authorization flows. For example, a typical OpenID Connect compliant web application will go through the /oauth/authorize endpoint using the authorization code flow.</li><li>When the authorization is granted, the authorization server returns an access token to the application.</li><li>The application uses the access token to access a protected resource (like an API).</li></ol><p>Do note that with signed tokens, all the information contained within the token is exposed to users or other parties, even though they are unable to change it. This means you should not put secret information within the token.</p><h3 id="Why-should-we-use-JSON-Web-Tokens"><a href="#Why-should-we-use-JSON-Web-Tokens" class="headerlink" title="Why should we use JSON Web Tokens?"></a>Why should we use JSON Web Tokens?</h3><p>Let’s talk about the benefits of <strong>JSON Web Tokens (JWT)</strong> when compared to <strong>Simple Web Tokens (SWT)</strong> and <strong>Security Assertion Markup Language Tokens (SAML)</strong>.</p><p>As JSON is less verbose than XML, when it is encoded its size is also smaller, making JWT more compact than SAML. This makes JWT a good choice to be passed in HTML and HTTP environments.</p><p>Security-wise, SWT can only be symmetrically signed by a shared secret using the HMAC algorithm. However, JWT and SAML tokens can use a public/private key pair in the form of a X.509 certificate for signing. Signing XML with XML Digital Signature without introducing obscure security holes is very difficult when compared to the simplicity of signing JSON.</p><p>JSON parsers are common in most programming languages because they map directly to objects. Conversely, XML doesn’t have a natural document-to-object mapping. This makes it easier to work with JWT than SAML assertions.</p><p>Regarding usage, JWT is used at Internet scale. This highlights the ease of client-side processing of the JSON Web token on multiple platforms, especially mobile.<br><img src="/2018/12/10/JSON-Web-Token/jwt4.png" alt></p><center><em>Comparison of the length of an encoded JWT and an encoded SAML</em></center>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;What-is-JSON-Web-Token&quot;&gt;&lt;a href=&quot;#What-is-JSON-Web-Token&quot; class=&quot;headerlink&quot; title=&quot;What is JSON Web Token?&quot;&gt;&lt;/a&gt;What is JSON Web Token?&lt;/h3&gt;&lt;p&gt;JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the &lt;strong&gt;HMAC&lt;/strong&gt; algorithm) or a public/private key pair using &lt;strong&gt;RSA&lt;/strong&gt; or &lt;strong&gt;ECDSA&lt;/strong&gt;.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="加密" scheme="https://oldmee.github.io/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>旅游之云南</title>
    <link href="https://oldmee.github.io/2018/10/01/travel-yunnan-erhai/"/>
    <id>https://oldmee.github.io/2018/10/01/travel-yunnan-erhai/</id>
    <published>2018-10-01T03:46:00.000Z</published>
    <updated>2019-03-04T02:19:40.077Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十一带着家人去看诗和远方。</p></blockquote><a id="more"></a><video src="1551584899727024.mp4" width="320" height="180" controls="controls"></video>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;十一带着家人去看诗和远方。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="旅游" scheme="https://oldmee.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://oldmee.github.io/2018/09/12/distributed-transaction/"/>
    <id>https://oldmee.github.io/2018/09/12/distributed-transaction/</id>
    <published>2018-09-12T05:58:00.000Z</published>
    <updated>2019-03-02T06:06:03.090Z</updated>
    
    <content type="html"><![CDATA[<p>现在面试，分布式系统成了标配，而分布式系统带来的分布式事务也成了标配了。因为你做系统肯定要用事务吧，如果是分布式系统，肯定要用分布式事务吧。先不说你搞过没有，起码你得明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。<br><a id="more"></a></p><p>分布式事务的实现主要有以下 5 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案/XA方案"></a>两阶段提交方案/XA方案</h3><p>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-XA.png" alt></p><h3 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h3><p>TCC 的全称是：Try、Confirm、Cancel。</p><p>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。<br>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。<br>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）<br>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心。</p><p>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-TCC.png" alt></p><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><p>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；<br>接着 A 系统将这个消息发送到 MQ 中去；<br>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；<br>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；<br>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；<br>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。<br>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-local-message-table.png" alt></p><h3 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h3><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><p>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；<br>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；<br>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；<br>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。<br>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。<br>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-reliable-message.png" alt></p><h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><p>这个方案的大致意思就是：</p><p>系统 A 本地事务执行完之后，发送个消息到 MQ；<br>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；<br>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在面试，分布式系统成了标配，而分布式系统带来的分布式事务也成了标配了。因为你做系统肯定要用事务吧，如果是分布式系统，肯定要用分布式事务吧。先不说你搞过没有，起码你得明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://oldmee.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="https://oldmee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="https://oldmee.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>我们都一样</title>
    <link href="https://oldmee.github.io/2018/06/12/we-are-pool-together/"/>
    <id>https://oldmee.github.io/2018/06/12/we-are-pool-together/</id>
    <published>2018-06-12T01:39:00.000Z</published>
    <updated>2019-03-14T02:17:21.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我做了一个梦，很梦幻的梦，醒来之后才发现，这只是世界跟我开的一个玩笑，更加可笑的是他跟很多人都开了同一个玩笑。</p></blockquote><a id="more"></a><h3 id="故事FM"><a href="#故事FM" class="headerlink" title="故事FM"></a>故事FM</h3><p>我是故事FM的一名听众，从第一集听到现在，一集不落，从里面筛选了跟我经历类似的四个故事，记录一下，时刻警醒自己对美好生活的珍惜。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=2060043174&auto=1&height=66"></iframe><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=2058854295&auto=1&height=66"></iframe><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=2058262105&auto=1&height=66"></iframe><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=3&id=2057416000&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;我做了一个梦，很梦幻的梦，醒来之后才发现，这只是世界跟我开的一个玩笑，更加可笑的是他跟很多人都开了同一个玩笑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="人生" scheme="https://oldmee.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix 的线程池隔离和信号量隔离</title>
    <link href="https://oldmee.github.io/2018/02/26/Hystrix-isolation/"/>
    <id>https://oldmee.github.io/2018/02/26/Hystrix-isolation/</id>
    <published>2018-02-26T10:38:00.000Z</published>
    <updated>2019-02-26T11:04:42.780Z</updated>
    
    <content type="html"><![CDATA[<p>信号量的隔离：<br> it executes on the calling thread and concurrent requests are limited by the semaphore count.</p><p>每次调用线程，当前请求通过计数信号量进行限制，当信号大于了最大请求数（maxConcurrentRequests）时，进行限制，调用fallback接口快速返回。<br><a id="more"></a></p><p><img src="/2018/02/26/Hystrix-isolation/Hystrix_02.jpg" alt></p><p>最重要的是，信号量的调用是同步的，也就是说，每次调用都得阻塞调用方的线程，直到结果返回。这样就导致了无法对访问做超时（只能依靠调用协议超时，无法主动释放）</p><p>官网对信号量隔离的描述建议</p><p>Generally the only time you should use semaphore isolation for HystrixCommands is when the call is so high volume (hundreds per second, per instance) that the overhead of separate threads is too high; this typically only applies to non-network calls.</p><p>隔离的细粒度太高，数百个实例需要隔离，此时用线程池做隔离开销过大通常这种都是非网络调用的情况下线程池隔离:<br>it executes on a separate thread and concurrent requests are limited by the number of threads in the thread-pool<br>通过每次都开启一个单独线程运行。它的隔离是通过线程池，即每个隔离粒度都是个线程池，互相不干扰</p><p>Commands executed in threads have an extra layer of protection against latencies beyond what network timeouts can offer.<br>线程池隔离方式，等于多了一层的保护措施，可以通过hytrix直接设置超时，超时后直接返回。</p><p><img src="/2018/02/26/Hystrix-isolation/Hystrix_01.jpg" alt></p><p>最后总结对比下：</p><table><thead><tr><th style="text-align:center">隔离方式</th><th style="text-align:center">是否支持超时</th><th style="text-align:center">是否支持熔断</th><th style="text-align:center">隔离原理</th><th style="text-align:center">是否是异步调用</th><th style="text-align:center">资源消耗</th></tr></thead><tbody><tr><td style="text-align:center">线程池隔离</td><td style="text-align:center">支持,可直接返回</td><td style="text-align:center">支持,当线程池到达maxSize后,再请求会触发fallback接口进行熔断</td><td style="text-align:center">每个服务单独用线程池</td><td style="text-align:center">可以是异步,也可以是同步。看调用的方法</td><td style="text-align:center">大,大量线程的上下文切换，容易造成机器负载高</td></tr><tr><td style="text-align:center">信号量隔离</td><td style="text-align:center">不支持,如果阻塞，只能通过调用协议（如:socket超时才能返回）</td><td style="text-align:center">支持，当信号量达到maxConcurrentRequests后。再请求会触发fallback</td><td style="text-align:center">通过信号量的计数器</td><td style="text-align:center">同步调用,不支持异步</td><td style="text-align:center">小,只是个计数器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号量的隔离：&lt;br&gt; it executes on the calling thread and concurrent requests are limited by the semaphore count.&lt;/p&gt;
&lt;p&gt;每次调用线程，当前请求通过计数信号量进行限制，当信号大于了最大请求数（maxConcurrentRequests）时，进行限制，调用fallback接口快速返回。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring cloud" scheme="https://oldmee.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Beanstalk（内存队列）</title>
    <link href="https://oldmee.github.io/2018/02/26/Beanstalk/"/>
    <id>https://oldmee.github.io/2018/02/26/Beanstalk/</id>
    <published>2018-02-25T16:22:00.000Z</published>
    <updated>2019-02-26T09:15:09.314Z</updated>
    
    <content type="html"><![CDATA[<p>Beanstalk是一个高性能、轻量级的、分布式的、内存型的消息队列系统。最初设计的目的是想通过后台异步执行耗时的任务来降低高容量Web应用系统的页面访问延迟。其实Beanstalkd是典型的类Memcached设计，协议和使用方式都是同样的风格。其基本设计思想很简单：高性能离不开异步，异步离不开队列，而内部都是生产者-消费者模式的。<br><a id="more"></a></p><h3 id="Beanstalk介绍："><a href="#Beanstalk介绍：" class="headerlink" title="Beanstalk介绍："></a>Beanstalk介绍：</h3><p>　　那下面开始说beanstalk了。首先说beanstalk其实并不是JMS规范的，也并不严格遵守AMQP协议。有人说Beanstalk之于RabbitMQ，就好比Nginx之于Apache。它更简单，轻量级，高性能，易使用。但是相比kafka，数据处理能力还是有差距，所以我们现在其实在逐渐替代它。但它有些很易用的特殊功能，后面会讲到。</p><p>　　Beanstalk主要包括4个部分。</p><p>　　1&gt; job:一个需要异步处理的任务，需要放在一个tube中。</p><p>　　2&gt; tube:一个有名的任务队列，用来存储统一类型的job，是producer和consumer操作的对象。</p><p>　　3&gt; producer:job的生产者，通过put命令来将一个job放到一个tube中。</p><p>　　4&gt; consumer:job的消费者，通过reserve、release、bury、delete命令来获取job或改变job的状态。</p><p>　　刚才说Beanstalk有一些特殊的好用功能。那就是它支持任务优先级(priority)、延时(delay)、超时重发(time-to-run)和预留(buried)，能够很好的支持分布式的后台任务和定时任务处理。这些特性是和beanstalk工作过程密切相关。</p><p>　　Beanstalk的一个job的生命周期有READY、RESERVED、DELAYED、BURIED四种。</p><p>　　当producer直接put一个job时，job就是READY状态，等待consumer来处理。如果选择延迟put，job就先到DELAYED状态，到指定时间再READY。consumer获取了READY的job，此状态就为RESERVED。这样其他consumer不能再操作此job。当consumer完成该job后，可以选择delete、release或者bury。</p><p>　　delete之后，job不能再获取。release的job可以重新迁移或延迟迁移回READY。bury的job可以被休眠，需要的时候再READY或者delete掉。</p><h3 id="Beanstalk使用场景："><a href="#Beanstalk使用场景：" class="headerlink" title="Beanstalk使用场景："></a>Beanstalk使用场景：</h3><p>　　用作延时队列：比如可以用于如果用户30分钟内不操作，任务关闭。</p><p>　　用作循环队列：用release命令可以循环执行任务，比如可以做负载均衡任务分发。</p><p>　　用作兜底机制：比如一个请求有失败的概率，可以用Beanstalk不断重试，设定超时时间，时间内尝试到成功为止。</p><p>　　用作定时任务：比如可以用于专门的后台任务。</p><p>　　用作异步操作：这是所有消息队列都最常用的，先将任务仍进去，顺序执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Beanstalk是一个高性能、轻量级的、分布式的、内存型的消息队列系统。最初设计的目的是想通过后台异步执行耗时的任务来降低高容量Web应用系统的页面访问延迟。其实Beanstalkd是典型的类Memcached设计，协议和使用方式都是同样的风格。其基本设计思想很简单：高性能离不开异步，异步离不开队列，而内部都是生产者-消费者模式的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatis数据库操作空指针异常</title>
    <link href="https://oldmee.github.io/2017/05/10/MyBatis/"/>
    <id>https://oldmee.github.io/2017/05/10/MyBatis/</id>
    <published>2017-05-10T06:54:00.000Z</published>
    <updated>2019-03-14T02:15:48.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候，你认为出问题的地方并不是你想的地方。</p></blockquote><a id="more"></a><p>明明数据库都设置了id自增，xml也做了相关的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useGeneratedKeys=<span class="string">"true"</span> keyProperty=<span class="string">"id"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AccountMapper accountMapper;</span><br></pre></td></tr></table></figure><p>但数据insert依然报空指针异常，控制台很明显可以看出id为null导致的异常，于是静下心来想想，结果发现插入的这个mapper被我放在一个工具类里了，方法设为了静态，所以变量mapper也被设置为static，编译时没有任何问题，但是一跑起来就一直是空指针异常，其实跟MyBatis没啥关系，是因为spring没法注入静态变量，类被加载字节码的时候变量已经初始化了，也就是给该变量分配内存了，导致spring忽略静态变量。所以上面的写法自然就错了。</p><p>Spring 依赖注入是依赖set方法，静态变量不属于对象，只属于类。解决方法就是加上非静态的set方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountMapper</span><span class="params">(AccountMapper accountMapper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.accountMapper = accountMapper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者在spring的配置文件中配置（说白了也是set方法，都一样）<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean value=<span class="string">"test"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"x.x.x.Util"</span>&gt;</span><br><span class="line">&lt;property value=<span class="string">"accountMapper"</span> ref=<span class="string">"accountMapper"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;有时候，你认为出问题的地方并不是你想的地方。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="https://oldmee.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>spring security+oauth2的SSO方案</title>
    <link href="https://oldmee.github.io/2017/03/17/spring-security-oauth2-SSO/"/>
    <id>https://oldmee.github.io/2017/03/17/spring-security-oauth2-SSO/</id>
    <published>2017-03-17T09:03:00.000Z</published>
    <updated>2019-03-18T03:29:16.569Z</updated>
    
    <content type="html"><![CDATA[<p>springboot项目加入spring security其实是很简单的事情，主要就是config方法的重写。<br><a id="more"></a></p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableOAuth</span>2Sso</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.antMatcher(<span class="string">"/**"</span>)</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/updateResult**"</span>,<span class="string">"/getOneAccount**"</span>,<span class="string">"/login**"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>login在校验oauth服务器的时候要用到，所以这里需要放行。注解<code>@EnableOAuth2Sso</code>就是开启客户端sso</p><p>springboot的配置文件中增加对oauth校验服务器的访问配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#security</span><br><span class="line">security.oauth2.client.client-id=SampleClientId</span><br><span class="line">security.oauth2.client.client-secret=secret</span><br><span class="line">security.oauth2.client.access-token-uri=http:<span class="comment">//localhost:8081/auth/oauth/token</span></span><br><span class="line">security.oauth2.client.user-authorization-uri=http:<span class="comment">//localhost:8081/auth/oauth/authorize</span></span><br><span class="line"></span><br><span class="line">security.oauth2.resource.user-info-uri=http:<span class="comment">//localhost:8081/auth/user/me</span></span><br></pre></td></tr></table></figure><h3 id="授权层"><a href="#授权层" class="headerlink" title="授权层"></a>授权层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthServerConfig</span> <span class="keyword">extends</span> <span class="title">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BCryptPasswordEncoder passwordEncoder;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(<span class="keyword">final</span> AuthorizationServerSecurityConfigurer oauthServer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        oauthServer.tokenKeyAccess(<span class="string">"permitAll()"</span>)</span><br><span class="line">            .checkTokenAccess(<span class="string">"isAuthenticated()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(<span class="keyword">final</span> ClientDetailsServiceConfigurer clients)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        clients.inMemory()</span><br><span class="line">            .withClient(<span class="string">"SampleClientId"</span>)</span><br><span class="line">            .secret(passwordEncoder.encode(<span class="string">"secret"</span>))</span><br><span class="line">            .authorizedGrantTypes(<span class="string">"authorization_code"</span>)</span><br><span class="line">            .scopes(<span class="string">"user_info"</span>)</span><br><span class="line">            .autoApprove(<span class="keyword">true</span>)</span><br><span class="line">            .redirectUris(<span class="string">"http://localhost:8848/login"</span>,<span class="string">"http://localhost:8849/login"</span>,<span class="string">"http://localhost:8850/login"</span>,<span class="string">"http://localhost:8082/ui/login"</span>,<span class="string">"http://localhost:8083/ui2/login"</span>,<span class="string">"http://localhost:8082/login"</span>,<span class="string">"http://www.example.com/"</span>)</span><br><span class="line">        <span class="comment">// .accessTokenValiditySeconds(3600)</span></span><br><span class="line">        ; <span class="comment">// 1 hour</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有验证服务器当然是授权码模式，redirectUris中加入所有重定向的地址，也就是客户端的url，因为通过验证服务器成功后需要重定向到客户端。</p><p>接下来就是SecurityConfig的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// @formatter:off</span></span><br><span class="line">        http.requestMatchers()</span><br><span class="line">            .antMatchers(<span class="string">"/login"</span>, <span class="string">"/oauth/authorize"</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .anyRequest()</span><br><span class="line">            .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin()</span><br><span class="line">            .permitAll()</span><br><span class="line">            .and().csrf().disable();</span><br><span class="line">    &#125; <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">// @formatter:off</span></span><br><span class="line">        auth.inMemoryAuthentication()</span><br><span class="line">            .withUser(<span class="string">"admin"</span>)</span><br><span class="line">            .password(passwordEncoder().encode(<span class="string">"admin"</span>))</span><br><span class="line">            .roles(<span class="string">"USER"</span>);</span><br><span class="line">    &#125; <span class="comment">// @formatter:on</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Order(1)因为上一个文件中用到了这里的ECryptPasswordEncoder，所以这里要优先装配。<code>/oauth/authorize</code>是oauth默认的校验地址。</p><p>详细代码托管在github：</p><ul><li><a href="https://github.com/oldmee/spring-security-sso" target="_blank" rel="noopener">下载地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;springboot项目加入spring security其实是很简单的事情，主要就是config方法的重写。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty</title>
    <link href="https://oldmee.github.io/2017/03/01/netty/"/>
    <id>https://oldmee.github.io/2017/03/01/netty/</id>
    <published>2017-03-01T08:47:00.000Z</published>
    <updated>2019-03-01T10:45:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/03/01/netty/netty.jpg" alt><br>Netty 是互联网中间件领域使用最广泛最核心的网络通信框架。上图中可以看到，几乎所有互联网中间件或者大数据领域均离不开 Netty。<br><a id="more"></a></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO编程模型中，新来一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责，那么他是怎么做到的？我们用一幅图来对比一下IO与NIO</p><p><img src="/2017/03/01/netty/netty01.jpg" alt><br><img src="/2017/03/01/netty/netty02.jpg" alt></p><p>IO模型中，一个连接来了，会创建一个线程，对应一个while死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读，因此，很多个while死循环都白白浪费掉了，因为读不出啥数据。</p><p>而在NIO模型中，他把这么多while死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个while死循环就能监测1w个连接是否有数据可读的呢？</p><p>这就是NIO模型中selector的作用，一条连接来了之后，现在不创建一个while死循环去监听是否有数据可读了，而是直接把这条连接注册到selector上，然后，通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的例子说明IO与NIO的区别。</p><p>在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一共有100个小朋友，有两种方案可以解决小朋友上厕所的问题：</p><p>每个小朋友配一个老师。每个老师隔段时间询问小朋友是否要上厕所，如果要上，就领他去厕所，100个小朋友就需要100个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去上，这就是IO模型，一个连接对应一个线程。<br>所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所的小朋友批量领到厕所，这就是NIO模型，所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到一个线程，然后批量轮询。</p><p>这就是NIO模型解决线程资源受限的方案，实际开发过程中，我们会开多个线程，每个线程都管理着一批连接，相对于IO模型中一个线程管理一条连接，消耗的线程资源大幅减少</p><h3 id="JDK-NIO的缺点"><a href="#JDK-NIO的缺点" class="headerlink" title="JDK NIO的缺点"></a>JDK NIO的缺点</h3><ul><li>JDK的NIO编程需要了解很多的概念，编程复杂，对NIO入门非常不友好，编程模型不友好，ByteBuffer的api简直反人类</li><li>对NIO编程来说，一个比较合适的线程模型能充分发挥它的优势，而JDK没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现</li><li>JDK的NIO底层由epoll实现，该实现饱受诟病的空轮训bug会导致cpu飙升100%</li><li>项目庞大之后，自行实现的NIO很容易出现各类bug，维护成本较高，上面这一坨代码我都不能保证没有bug</li></ul><h3 id="netty的优点"><a href="#netty的优点" class="headerlink" title="netty的优点"></a>netty的优点</h3><ul><li>设计优雅，适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池；真正的无连接数据报套接字支持（自 3.1 起）。</li><li>使用方便，详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</li><li>高性能，吞吐量更高，延迟更低；减少资源消耗；最小化不必要的内存复制。</li><li>安全，完整的 SSL/TLS 和 StartTLS 支持。</li><li>社区活跃，不断更新，社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。</li></ul><h3 id="使用Netty而不使用JDK原生NIO的原因"><a href="#使用Netty而不使用JDK原生NIO的原因" class="headerlink" title="使用Netty而不使用JDK原生NIO的原因"></a>使用Netty而不使用JDK原生NIO的原因</h3><ul><li>使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞</li><li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型</li><li>Netty自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</li><li>Netty解决了JDK的很多包括空轮询在内的bug</li><li>Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理</li><li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li><li>Netty社区活跃，遇到问题随时邮件列表或者issue</li><li>Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li></ul><h3 id="Netty的helloWorld"><a href="#Netty的helloWorld" class="headerlink" title="Netty的helloWorld"></a>Netty的helloWorld</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.6.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boos = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        serverBootstrap</span><br><span class="line">                .group(boos, worker)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> </span>&#123;</span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Channel channel = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>).channel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> Date() + <span class="string">": hello world!"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/03/01/netty/netty.jpg&quot; alt&gt;&lt;br&gt;Netty 是互联网中间件领域使用最广泛最核心的网络通信框架。上图中可以看到，几乎所有互联网中间件或者大数据领域均离不开 Netty。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="https://oldmee.github.io/tags/netty/"/>
    
      <category term="框架" scheme="https://oldmee.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
