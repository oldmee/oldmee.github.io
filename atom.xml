<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oldmee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oldmee.github.io/"/>
  <updated>2019-02-26T01:32:07.811Z</updated>
  <id>https://oldmee.github.io/</id>
  
  <author>
    <name>oldmee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://oldmee.github.io/2019/02/26/chain-of-responsibility-pattern/"/>
    <id>https://oldmee.github.io/2019/02/26/chain-of-responsibility-pattern/</id>
    <published>2019-02-25T16:01:24.000Z</published>
    <updated>2019-02-26T01:32:07.811Z</updated>
    
    <content type="html"><![CDATA[<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br><a id="more"></a><br>应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p><p>责任链模式demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">AbstractLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ConsoleLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"Standard Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ErrorLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"File::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ChainPatternDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">      AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">      AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"> </span><br><span class="line">      errorLogger.setNextLogger(fileLogger);</span><br><span class="line">      fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> errorLogger;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, </span><br><span class="line">         <span class="string">"This is an information."</span>);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </span><br><span class="line">         <span class="string">"This is an debug level information."</span>);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </span><br><span class="line">         <span class="string">"This is an error information."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Standard Console::Logger: This is an information.</span><br><span class="line">File::Logger: This is an debug level information.</span><br><span class="line">Standard Console::Logger: This is an debug level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">File::Logger: This is an error information.</span><br><span class="line">Standard Console::Logger: This is an error information.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最高级别的error会被输出三次，最低级别的info只会输出一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo-bugs-000</title>
    <link href="https://oldmee.github.io/2019/02/25/hexo-bugs-000/"/>
    <id>https://oldmee.github.io/2019/02/25/hexo-bugs-000/</id>
    <published>2019-02-25T12:04:00.000Z</published>
    <updated>2019-02-26T01:32:07.812Z</updated>
    
    <content type="html"><![CDATA[<p>在hexo本地服务器模式下，一旦文章内容过多（具体没测试，可以多放些内容试试），则生成的html在本地就会出问题，没有上一页下一页以及脚标信息，在浏览器里查看网页源代码发现都是些小方格，不知道是什么鬼。但是用户不知道啊，我搞了半天，发现原来是个bug，部署到github上一切正常，真的是脑壳痛……<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在hexo本地服务器模式下，一旦文章内容过多（具体没测试，可以多放些内容试试），则生成的html在本地就会出问题，没有上一页下一页以及脚标信息，在浏览器里查看网页源代码发现都是些小方格，不知道是什么鬼。但是用户不知道啊，我搞了半天，发现原来是个bug，部署到github上一切正常，真的是脑壳痛……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="bugs" scheme="https://oldmee.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>使用 Protocol Buffers 代替 JSON 的五个原因</title>
    <link href="https://oldmee.github.io/2019/02/25/protocol-buffers/"/>
    <id>https://oldmee.github.io/2019/02/25/protocol-buffers/</id>
    <published>2019-02-25T09:53:25.000Z</published>
    <updated>2019-02-26T01:32:07.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/25/protocol-buffers/pb.png" alt><br><a id="more"></a></p><h3 id="原因一-模式本身很不错"><a href="#原因一-模式本身很不错" class="headerlink" title="原因一: 模式本身很不错"></a>原因一: 模式本身很不错</h3><p>有一种痛苦的讽刺指向一个事实，我们小心谨慎地在我们的数据库里面编写数据模型，维护各个层次的代码，保持这些数据模型处于控制之中，当我们想要发送数据连接到另一个服务的时候，要求所有的疑虑都要被考虑到。然而，我们往往依靠的是在边界上与我们的系统之间不一致的代码，我们的系统不能强制结构化我们的数据组件，这是如此的重要，编码的语义是你曾经的业务对象，在proto格式中，它足以帮助并保证应用程序之间的信号不会丢失，而界限就在你所创建并执行的业务规则。</p><h3 id="原因二-无偿地向后兼容"><a href="#原因二-无偿地向后兼容" class="headerlink" title="原因二: 无偿地向后兼容"></a>原因二: 无偿地向后兼容</h3><p>被编号的字段在proto的定义中排除了所需的版本检查，这是其中一个被明确表述的动机（为什么这样设计和实现Protocol Buffers）。如同开发者文档中声明的那样，协议被设计成能在一定程度上避免出现像下面这样的“丑陋的代码”，下面的代码用来检测协议的版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (version == <span class="number">3</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (version == <span class="number">5</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同编号字段一样, 你必须改变编码习惯，朝着能向老版本维护和向后兼容的方向改变。正如在文档中的声明那样，曾经 Protocol Buffers 是这样被介绍的：</p><p>“新的字段可以很容易被引入，并且不需要中间服务去检查数据就能被解析，通过数据不必知道所有的字段。”</p><p>已经部署各种JSON的服务器已经遭受各种与发展模式以及向后兼容的相关问题。我现在深信编号字段能防止错误，并且能在新功能和服务的推出上做到简化。</p><h3 id="原因三-更少的样本代码"><a href="#原因三-更少的样本代码" class="headerlink" title="原因三: 更少的样本代码"></a>原因三: 更少的样本代码</h3><p>除了显式的版本检查和缺乏后续的兼容性，JSON终端在HTTP上的基础服务通常依赖专门的手写样板代码去处理Ruby对象的编码和解码。解析和反解析类常常包含隐藏的业务逻辑，它暴露了手动解析每个新的数据类型的缺陷，当一个类通过Protocol Buffers产生（你一般就不会再去触碰它），它能提供大量相似的方法，还避免了大量头痛的事情。随着模式的发展，你将会用proto产生类（应当承认，一旦你更新他们），你可以把更多的空间留给你所关注的挑战（保持你的应用运行和持续构建产品）。</p><h3 id="原因四-验证和可扩展性"><a href="#原因四-验证和可扩展性" class="headerlink" title="原因四: 验证和可扩展性"></a>原因四: 验证和可扩展性</h3><p>required，optional 和 repeated关键字在Protocol Buffers中的定义是非常强大的。它们允许你去编码，在模式级别，形象化你的数据结构和去实现类怎样工作（每种编程语言处理）的细节。Ruby的protocol_buffers库将会提升异常，例如：如果一个对象实例没有填写必填的字段，你试着去对这样一个对象实例编码，就会提升异常。通过简单地编辑一个新的编号字段的值，你可以把一个字段从required变成optional或者反之亦然。有了这种灵活编码的语义序列化格式，大大增强了其功能。</p><p>因为你还可以嵌入proto，定义内部的其他成员，你也可以拥有通用的Request和Response结构，它还允许其他数据结构的传输并确保传输连接上，它为服务器间通讯实现真正的灵活性和安全的数据传输提供了机会。类似Riak的数据库系统使用Protocol Buffers有巨大的效果——因为有了一些启示，我建议重新审视那些接口。</p><h3 id="原因五：建议的语言互操作性"><a href="#原因五：建议的语言互操作性" class="headerlink" title="原因五：建议的语言互操作性"></a>原因五：建议的语言互操作性</h3><p>因为Protocol Buffers已经被多种语言实现，在你的架构中多语言混合的应用程序之间的互操作性变得更简单。如果你引入了一个新的服务在JAVA或者GO中，甚至和用Node或者Clojure或者Scala实现的后端通讯，你只需简单的把proto文件交给目标语言编写的代码生成器，你将在这些架构之间获得较好的安全和互操作性。平台特定数据类型的细节被目标语言处理，你将更多的关注你的问题的困难部分，而不是匹配字段和数据类型在JSON的编码和解码方案中。</p><p><br></p><h3 id="什么时候更适合使用JSON"><a href="#什么时候更适合使用JSON" class="headerlink" title="什么时候更适合使用JSON?"></a>什么时候更适合使用JSON?</h3><p>有些时候JSON比Protocol Buffers更适合，包括如下的场景：</p><ul><li>你需要或者想让数据对人是可读的</li><li>来自于服务的数据是直接发送到web浏览器</li><li>你的服务端应用程序是用javaScript编写的</li><li>你不准备把数据模型绑定到模式上</li><li>你没有带宽添加另外一个工具到你的军火库</li><li>运行不同类型的网络服务的运营负担过大</li></ul><p>可能还有更多的情况。最后，总之，这是很重要的在心里权衡和不要盲目的选择一项技术。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Protocol Buffers提供了几种相对JSON在内部服务之间在线传输数据的引人注目的优势。并没有完全的替换JSON，特别是服务和web浏览器直接通讯的情况，Protocol Buffers提供了真正的优势不仅在上面概述的方法，在编解码的速度和数据大小上有更多的优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/02/25/protocol-buffers/pb.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>敏感词过滤算法</title>
    <link href="https://oldmee.github.io/2019/02/25/deterministic-finite-automaton/"/>
    <id>https://oldmee.github.io/2019/02/25/deterministic-finite-automaton/</id>
    <published>2019-02-25T07:09:58.000Z</published>
    <updated>2019-02-25T07:27:50.213Z</updated>
    
    <content type="html"><![CDATA[<p>在实现文字过滤的算法中，DFA是唯一比较好的实现算法。DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。<br><a id="more"></a><br>敏感词会被构建成状态加标志位的形式，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 读取敏感词库，将敏感词放入HashSet中，构建一个DFA算法模型：&lt;br&gt; </span></span><br><span class="line"><span class="comment">     * 中 = &#123; </span></span><br><span class="line"><span class="comment">     *      isEnd = 0 </span></span><br><span class="line"><span class="comment">     *      国 = &#123; </span></span><br><span class="line"><span class="comment">     *           isEnd = 1 </span></span><br><span class="line"><span class="comment">     *           人 = &#123;isEnd = 0 </span></span><br><span class="line"><span class="comment">     *                民 = &#123;isEnd = 1&#125; </span></span><br><span class="line"><span class="comment">     *                &#125; </span></span><br><span class="line"><span class="comment">     *           男  = &#123; </span></span><br><span class="line"><span class="comment">     *                  isEnd = 0 </span></span><br><span class="line"><span class="comment">     *                   人 = &#123; </span></span><br><span class="line"><span class="comment">     *                        isEnd = 1 </span></span><br><span class="line"><span class="comment">     *                       &#125; </span></span><br><span class="line"><span class="comment">     *               &#125; </span></span><br><span class="line"><span class="comment">     *           &#125; </span></span><br><span class="line"><span class="comment">     *      &#125; </span></span><br><span class="line"><span class="comment">     *  五 = &#123; </span></span><br><span class="line"><span class="comment">     *      isEnd = 0 </span></span><br><span class="line"><span class="comment">     *      星 = &#123; </span></span><br><span class="line"><span class="comment">     *          isEnd = 0 </span></span><br><span class="line"><span class="comment">     *          红 = &#123; </span></span><br><span class="line"><span class="comment">     *              isEnd = 0 </span></span><br><span class="line"><span class="comment">     *              旗 = &#123; </span></span><br><span class="line"><span class="comment">     *                   isEnd = 1 </span></span><br><span class="line"><span class="comment">     *                  &#125; </span></span><br><span class="line"><span class="comment">     *              &#125; </span></span><br><span class="line"><span class="comment">     *          &#125; </span></span><br><span class="line"><span class="comment">     *      &#125; </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> null  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019年2月25日 下午3:04:20 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyWordSet  敏感词库 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@version</span> 1.0 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实现文字过滤的算法中，DFA是唯一比较好的实现算法。DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何设计一个高并发系统</title>
    <link href="https://oldmee.github.io/2019/02/25/design-high-concurrency-system/"/>
    <id>https://oldmee.github.io/2019/02/25/design-high-concurrency-system/</id>
    <published>2019-02-25T04:39:57.000Z</published>
    <updated>2019-02-25T07:28:36.364Z</updated>
    
    <content type="html"><![CDATA[<p>有过高并发实践经验的当然最好了，但事实是这很难，除非是这家公司是匹黑马，你刚去的时候用户不多，但是行业发展好，每月几百万用户用户的增长，你不断的踩坑，不断地升级公司的系统架构，现在不太可能实现了，互联网巨头们都已经尘埃落定，所以大部分人基本上也碰不到这些个情况了，但是互联网公司面试要问呐，咋整？<br><a id="more"></a><br>第一类当然是最好的，有过经验的，没有怎么办？退而求其次！你没吃过猪肉还没见过猪跑？把理论玩精了，总比对高并发系统一无所知的人要好的多吧。</p><p>如果你属于第二种情况，试试从下面六个方面来设计一个高并发的系统：</p><ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><img src="/2019/02/25/design-high-concurrency-system/hc.jpg" alt></p><h3 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h3><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><blockquote><p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p><footer><strong>--很现实但没什么意义的话</strong></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有过高并发实践经验的当然最好了，但事实是这很难，除非是这家公司是匹黑马，你刚去的时候用户不多，但是行业发展好，每月几百万用户用户的增长，你不断的踩坑，不断地升级公司的系统架构，现在不太可能实现了，互联网巨头们都已经尘埃落定，所以大部分人基本上也碰不到这些个情况了，但是互联网公司面试要问呐，咋整？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图书列表清单</title>
    <link href="https://oldmee.github.io/2019/02/25/book-list/"/>
    <id>https://oldmee.github.io/2019/02/25/book-list/</id>
    <published>2019-02-25T01:29:22.000Z</published>
    <updated>2019-02-25T07:31:04.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>老话说的好：少打王者多读书。</p></blockquote><a id="more"></a><h3 id="阅读清单"><a href="#阅读清单" class="headerlink" title="阅读清单"></a>阅读清单</h3><blockquote><p>2018-12-08<br>第一批次</p></blockquote><ul><li>Java编程思想 第4版</li><li>Head First 设计模式</li><li>深入理解Java虚拟机 JVM高级特性与最佳实践</li><li>Effective Java英文版 第三版</li><li>重构 改善既有代码的设计</li><li>Docker技术入门与实战</li><li>Hadoop权威指南第四版</li><li>Hive编程指南</li><li>Spark快速大数据分析<br><br></li></ul><blockquote><p>2019-01-24<br>第二批次</p></blockquote><ul><li>Effective Java中文版 第三版<br><br></li></ul><blockquote><p>2019-02-20<br>第三批次</p></blockquote><ul><li>RocketMQ技术内幕</li><li>企业私有云建设指南</li><li>ZooKeeper分布式过程协同技术详解</li><li>架构即未来</li><li>架构真经</li><li>Java机器学习</li></ul><p>…未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;老话说的好：少打王者多读书。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按键精灵编码最佳实践</title>
    <link href="https://oldmee.github.io/2019/02/22/tsy-coding-best-practice/"/>
    <id>https://oldmee.github.io/2019/02/22/tsy-coding-best-practice/</id>
    <published>2019-02-22T08:08:55.000Z</published>
    <updated>2019-02-25T07:30:35.441Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总来来说就是一次循环就执行一个动作，代码按照界面来操作（到了这个界面应该做什么动作）<br>遵循这个理论下面是具体的执行标准</p></blockquote><a id="more"></a><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><ul><li>用else if代替单条if</li><li>每条else if代表一个界面</li></ul><h3 id="Debug技巧"><a href="#Debug技巧" class="headerlink" title="Debug技巧"></a>Debug技巧</h3><ul><li>刚修改的地方全部注释，缩小范围</li><li>注释一整段if语句，缩小范围</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;总来来说就是一次循环就执行一个动作，代码按照界面来操作（到了这个界面应该做什么动作）&lt;br&gt;遵循这个理论下面是具体的执行标准&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo Admin的使用</title>
    <link href="https://oldmee.github.io/2019/02/22/hexo-use/"/>
    <id>https://oldmee.github.io/2019/02/22/hexo-use/</id>
    <published>2019-02-22T03:22:00.000Z</published>
    <updated>2019-02-25T07:31:21.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是一个坑"><a href="#这是一个坑" class="headerlink" title="这是一个坑"></a>这是一个坑</h3><p>安装方式我就不说了，就是按照网上说的那样，我主要说一下Deploy中的脚本怎么配置，网上都是类似这种<br><a id="more"></a><br><blockquote><p>./xxxx.sh</p></blockquote></p><p>完了我也傻不拉几的按照这种方式写，后来发现这就是一个脚本，你不用deploy就用命令行运行也是一样的，<br>admin只是一个写markdown的工具，部署只是提供给你一个快捷键罢了，问题是我是Windows，居然也用.sh真是尴尬，改成.bat路径前面也不需要.这也是linux下的写法。deployCommand: ‘hexo-generate.bat’ 就行了。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>每次hexo deploy的时候是不是都要输入github用户名密码？<br>可以这样做</p><p>先配置一个环境变量</p><p><img src="/2019/02/22/hexo-use/home.png" style="margin-left:0px"></p><p>接着在你的用户目录（C:\Users\username）下新建一个叫 _netrc的文件(没有拓展名)<br>编辑这个文件</p><ul><li>machine github.com</li><li>login username</li><li>password password</li></ul><p>设置好这些后，当你再次部署时，就不用输入用户名和密码了。</p><h3 id="tips2"><a href="#tips2" class="headerlink" title="tips2"></a>tips2</h3><p>hexo admin可以配置用户名和密码，密码需要用bcrypt加密，方法如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BCryptDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 　　<span class="comment">// Hash a password for the first time</span></span><br><span class="line"> 　　　　String password = <span class="string">"testpassword"</span>;</span><br><span class="line">　　　　String hashed = BCrypt.hashpw(password, BCrypt.gensalt());</span><br><span class="line">　　　　System.out.println(hashed);</span><br><span class="line">　　<span class="comment">// gensalt's log_rounds parameter determines the complexity</span></span><br><span class="line">　　<span class="comment">// the work factor is 2**log_rounds, and the default is 10</span></span><br><span class="line">　　String hashed2 = BCrypt.hashpw(password, BCrypt.gensalt(<span class="number">12</span>));</span><br><span class="line"> </span><br><span class="line">　　<span class="comment">// Check that an unencrypted password matches one that has</span></span><br><span class="line">　　<span class="comment">// previously been hashed</span></span><br><span class="line">　　String candidate = <span class="string">"testpassword"</span>;</span><br><span class="line">　　<span class="comment">//String candidate = "wrongtestpassword";</span></span><br><span class="line">　　<span class="keyword">if</span> (BCrypt.checkpw(candidate, hashed))</span><br><span class="line">　　　　System.out.println(<span class="string">"It matches"</span>);</span><br><span class="line">　　<span class="keyword">else</span></span><br><span class="line">　　System.out.println(<span class="string">"It does not match"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这是一个坑&quot;&gt;&lt;a href=&quot;#这是一个坑&quot; class=&quot;headerlink&quot; title=&quot;这是一个坑&quot;&gt;&lt;/a&gt;这是一个坑&lt;/h3&gt;&lt;p&gt;安装方式我就不说了，就是按照网上说的那样，我主要说一下Deploy中的脚本怎么配置，网上都是类似这种&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo使用" scheme="https://oldmee.github.io/categories/hexo%E4%BD%BF%E7%94%A8/"/>
    
      <category term="hexo admin" scheme="https://oldmee.github.io/categories/hexo%E4%BD%BF%E7%94%A8/hexo-admin/"/>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="博客" scheme="https://oldmee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Class.forName(&quot;jdbc地址&quot;)到底在干啥</title>
    <link href="https://oldmee.github.io/2019/02/21/mysql-jdbc-driver-function/"/>
    <id>https://oldmee.github.io/2019/02/21/mysql-jdbc-driver-function/</id>
    <published>2019-02-21T04:56:51.000Z</published>
    <updated>2019-02-25T10:23:57.066Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/21/mysql-jdbc-driver-function/mysql.jpg" alt></p><blockquote><p>Talk is cheap，show me the code.</p><footer><strong>--老李</strong></footer></blockquote><a id="more"></a><p>Class.forName(“com.mysql.jdbc.Driver”).newInstance() （Java 9开始newInstance()就已经不赞成使用了）<br>等价于com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();</p><p>Class.forName()的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段（并没有创建新对象）</p><p>所以也可以这么写：com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();</p><p>再看看Driver的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mysql.jdbc</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="comment">// --------------------------------------------- //</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ~ Constructors   </span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据下面三条规则：</p><p>1.当调用一个类的静态变量时，这个类中的静态代码块会执行。【只有静态代码块会执行】</p><p>2.当调用一个 类的静态方法时，这个类中的静态代码块会执行。【只有静态代码块会执行】</p><p>3.当创建一个 类的一个实例时，这个类中的静态代码块、非静态代码块（也叫构造代码块）、创建实例的相应的构造方法都会执行。</p><p>什么？还不明白？</p><p>Class.forName(“com.mysql.jdbc.Driver”);<br>String url = “jdbc:mysql://127.0.0.1/test?useUnicode=true&amp;characterEncoding=utf-8”;<br>String user = “”;<br>String psw = “”;<br>Connection con = DriverManager.getConnection(url,user,psw);<br>Class.forName就是触发static代码块中driver注册到DriverManager的行为，注册完了就可以随便调用了呗。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/02/21/mysql-jdbc-driver-function/mysql.jpg&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Talk is cheap，show me the code.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;--老李&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>一秒钟搞懂分布式锁</title>
    <link href="https://oldmee.github.io/2019/02/21/zookeeper/"/>
    <id>https://oldmee.github.io/2019/02/21/zookeeper/</id>
    <published>2019-02-21T02:12:31.000Z</published>
    <updated>2019-02-25T07:37:25.410Z</updated>
    
    <content type="html"><![CDATA[<p>怎么可能一秒钟，起码也得一分钟吧~<br><a id="more"></a></p><h3 id="分布式锁获取思路"><a href="#分布式锁获取思路" class="headerlink" title="分布式锁获取思路"></a>分布式锁获取思路</h3><p>a、在zookeeper指定节点（locker）下创建临时顺序节点。</p><p>b、客户端调用createNode方法在locker下创建临时顺序节点，然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。</p><p>c、客户端获取到所有的子节点path之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。</p><p>d、如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。</p><p>e、之后，如果这个被关注的节点被删除了（释放锁的时候会删除该节点），则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎么可能一秒钟，起码也得一分钟吧~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>我的半生感悟</title>
    <link href="https://oldmee.github.io/2019/02/12/myLife/"/>
    <id>https://oldmee.github.io/2019/02/12/myLife/</id>
    <published>2019-02-12T02:09:00.000Z</published>
    <updated>2019-02-25T11:00:17.218Z</updated>
    
    <content type="html"><![CDATA[<p>学平上了年纪，有很多话要说……<br><a id="more"></a></p><h3 id="中年"><a href="#中年" class="headerlink" title="中年"></a>中年</h3><p>人到中年，有很多想法，也有很多困惑，今天是2019年第一天上班，本来说要昨天做个总结的，但是昨天不知道干嘛了，这个总结也是昨天突然想写的，今天补上吧（其实平时有很多想法都是灵光一闪，想记录着的，但是就是没记）。</p><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><p>关于家庭，感觉自己就像处在沼泽中在使劲挣扎着，特别不想动，累吗？好像也不是特别累，但就是不想动，又不得不动，给自己下个总结，就是人懒但是现在已经不是一个人了，拖家带口的，还得照顾家庭，所以还得挣扎，但是很不情愿，不情愿也没办法，人活在世总得担责任嘛。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>关于工作，越来越觉得上班是一件性价比极低的事情，在杭州干软件可能年薪二十到三十万就是一个坎了，往上升的途径应该很窄（我说的的大概率情况，开挂的情况不在我说的范围内，因为我就是一个普通的不能再普通的人了，没有幻想着开挂也没有幻想中500万大奖），把我未来的黄金10年重心都放在工作上，想想就可惜，主要是上班工作本质上是拿时间换钱，一种等价交换，时间没了就换不回钱了，不可能有任何积累，没有积累就不会有延续，就像买了瓶汽水喝完就没了，现在满脑子想的是怎么打造一个赚钱的机器，有了机器会轻松很多，虽然需要时不时的去维护一下，但是机器可以传承延续啊，还可以再打造别的机器啊，这样的人生岂不是更有趣一些，当然想法是美好的现实是残酷的，实现这个想法的前提是要有基本的生活保障，突然想人要是不吃饭，光靠光合作用就能活下去多好。</p><h3 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h3><p>关于困惑，有时候幻想自己已经不再为衣食住行发愁了，我下一步要干啥呢，每天看看电影，世界各地走走？嗯，刚开始可能还新鲜，但是3年以后，5年以后呢，一直这样吗，那多无聊啊，看新闻说郭涛15岁看了终结者后就想拍一部自己的科幻电影，直到今年流浪地球拍出来了，过程当然比较坎坷，但是梦想还是实现了，关于困惑我想说的是我就好像没有啥特别爱好，这是我比较困惑的地方，高晓松说，40不惑就是40岁以后不是没有惑了，而是40岁以后想不明白事就不去想了。我不知道我15岁想要啥，但是我知道我12岁想要啥，为啥是12岁呢，因为一轮生肖都走了一圈，那天家里给买了个大蛋糕还许了愿，当时许的愿就是能有一台打游戏的vcd，因为当时有个广告天天播，又能打游戏又能看电影的一台机器，一想到又能打游戏又能看电影真好，所以就许了这么一个愿望，虽然后来没得到这么一台机器，但是后来上大学我有了电脑啊，大概10年，这也算是愿望实现了吧。</p><h3 id="买房"><a href="#买房" class="headerlink" title="买房"></a>买房</h3><p>关于买房，12岁以后就没有什么特别大的愿望了，甚至大学里都没有什么想法，直到毕业后刚上班有工资了后就是特别想攒一笔10万人民币，当时也没想着拿这10万去干啥干啥，就想着有个目标呗，毕业也快10年了，这10万具体是啥时候攒起来不记得了，只记得15年年底已经到处跑着看房子了，当时也没想着买，就是看看，现在想想15年好像已经有10万了，但是离买的起还差20万，所以只是看看，想得是还得攒2年钱，结果16年9月份G20之后房价像火箭一样，之前看过的房17年10月份再挨个问过去房价都翻倍了，安安心心攒了一年钱，再去看的时候傻眼了，买房一下子提上日程了，看了一圈后，发现要想买房，必须降低自己原来的期望值（原来看的都是100坪左右的，小区环境比较好的），16年底看中的一套105平方2手房，首付加各种费35万拿不出来，最后只好作罢，直到17年3月份36万首付买了80个平的二手，真是一路的心酸，通过这次买房一下打破了固有思维（一直想一步到位然后住一辈子，现在不这么想了，现在想的是多大能力办多大事，而且房子过10年后开始变旧，而新的格局更好的产品也会开发出来），以后就是想着隔10年换一次房（卖旧买新）。 </p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>一些感悟，每个人都有瓶颈，上升到一定阶段后很难突破，就像父辈一样，他们已经完成了他们的使命，而我现在来到了瓶颈地，延续老的思维已经很难上升了，该想着怎么打破现状继续前行，如果打不破，我现在的状态就是下一代的起点。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>关于未来，生活还要继续。。。</p><p>by 花蝴蝶</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学平上了年纪，有很多话要说……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人生" scheme="https://oldmee.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>2018-null</title>
    <link href="https://oldmee.github.io/2018/02/26/2018-null/"/>
    <id>https://oldmee.github.io/2018/02/26/2018-null/</id>
    <published>2018-02-25T16:22:00.000Z</published>
    <updated>2019-02-26T01:32:07.811Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2017-null</title>
    <link href="https://oldmee.github.io/2017/02/26/2017-null/"/>
    <id>https://oldmee.github.io/2017/02/26/2017-null/</id>
    <published>2017-02-25T16:22:00.000Z</published>
    <updated>2019-02-26T01:32:07.811Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七牛云融合CDN到底怎么配置？</title>
    <link href="https://oldmee.github.io/2016/12/08/qiniu-CDN/"/>
    <id>https://oldmee.github.io/2016/12/08/qiniu-CDN/</id>
    <published>2016-12-08T09:58:00.000Z</published>
    <updated>2019-02-26T02:51:23.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生如戏，你得先有故事。</p><footer><strong>--老李</strong></footer></blockquote><a id="more"></a><p>由于来年头一个月公司产品接入了一个旅游项目，为了保证系统的稳定性，必须要对现有架构进行改进以应对大流量的冲击。</p><p>那么问题来了？怎么改？</p><p>首先，我得清楚项目目前的瓶颈在什么地方，项目的日常应用场景是怎样的？</p><p>我先来分析一下我们项目的情况：我们这个项目主要是应用AR技术进行娱乐，原理就是利用高通家的Vuforia SDK实现边缘识别来叠加模型，哪些图像要被识别是需要提前传到高通的服务器上的，服务器会生成几个Vuforia专用的识别文件（dataset），再将识别文件整合到项目中，识别到了需要调用什么模型自己配置就可以了。<br>我主管后台，围绕着Vuforia的结构开发了一套程序进行后台文件的管理，简单的说就是有哪些识别图，识别到了会出现什么效果等等。</p><p>上面是后台的应用场景，再来看看用户端的使用场景，用户端只有移动端，Android和IOS，原理是这样：启动我们的app会先加载一段配置文件（json），主要就是让手机知道，哪些图片可以被识别（这里多说一句，因为识别图片会越来越多，所以启动速度也越来越慢，我特意研究了一下国内easyAR的SDK，他们可以即时更换识别图片，而且不用传到服务器等待生成识别文件这么复杂，但是搞AR的那哥们在高通的Vuforia花了太多时间，多少还是有点经验的，万一换个SDK，没啥优势了，嗯……很恐怖，所以老技术人一般不会轻易尝试新的技术，因为自己占领的优势会立马失去，哎……），长时间的加载等待后进入了主界面。我们根据识别图开发了很多周边产品，比如说识别图印在T恤上，做成钥匙扣，等等等等，总之就是各种识别图附着在各种实物上，听到这里我们的商业模式也应运而生，没错，卖实物赚钱，app免费下！<br>用手机扫描识别图app就会认识并给出下载提示，什么？又要下载？解释一下，这次下的是模型，也就是识别到了之后展示的效果，一个3D模型，unity开发的，这里也是一个影响用户体验的地方，用户好不容易下载了我们的app，之后好不容易进入了主界面，完了还得下载，你是用户你糟不糟心，糟！现在还是改版后的，有分类的，第一版是所有的模型都在一个包下，也就是说，进入主界面后要一次性下载所有的模型，那酸爽，简直了~<br>改版后的对模型进行了分类，这样下载时间能短一点，但是换到另外一个分类又得重新下载（用户已经气晕在地上了……），下载后模型会缓存在手机本地，现在即使用户断网了也依然可以愉快的玩耍了。</p><p>写了一大段介绍app的应用场景，瓶颈已经很明显了，首先就是app启动的时候从服务拉取的那一段配置文件，其次就是下载的模型文件。怎么解决就很简单了，配置文件上缓存，因为读取的都是相同的内容，典型的读多写少的场景，模型文件是大文件，静态的，全部上CDN，这样，瓶颈就解决了，至少目前是解决了，应对来年的那个流量没有任何问题了。</p><p>好了，进入正题，缓存就不细讲了，不是本文的主角，来聊聊CDN吧。</p><p>CDN（Content Delivery Network）内容分发网络，就是厂家在地球的一些地方部署了服务器，作为仓库存放用户的文件，用户访问CDN服务器的时候会经过一个路由算法找到离访问者最近的一台服务器，这样就能实现快速访问，而且可以极大地减少自己服务器的压力，你想想啊，如果你的服务器在昆明，东北的用户访问你的服务器是不是要慢多了？因为距离远了嘛。CDN通过流量来收费，很合理，用的多，花的多，用的少，花的也少。</p><p>最后来看看CDN配置的具体步骤吧：</p><h3 id="1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图："><a href="#1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图：" class="headerlink" title="1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图："></a>1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_001.jpg" alt></p><h3 id="2、在融合CDN中创建加速域名列表，如下图："><a href="#2、在融合CDN中创建加速域名列表，如下图：" class="headerlink" title="2、在融合CDN中创建加速域名列表，如下图："></a>2、在融合CDN中创建加速域名列表，如下图：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_002.jpg" alt><br>加速域名随便写一个二级域名：a.b.com.cn  c.d.com  等等，写在这里，然后最后的源站配置选择第一个“七牛云存储”，并选择你刚才创建的那个空间。</p><h3 id="3、完成后你会看到这样的信息："><a href="#3、完成后你会看到这样的信息：" class="headerlink" title="3、完成后你会看到这样的信息："></a>3、完成后你会看到这样的信息：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_003.jpg" alt><br><img src="/2016/12/08/qiniu-CDN/CDN_003_1.jpg" alt></p><h3 id="4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢："><a href="#4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢：" class="headerlink" title="4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢："></a>4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_004.jpg" alt><br>主机记录写加速域名里你填写的那个二级域名的前段，请看上图B中介绍，主要就是把七牛给你的CNAME填写到正确的地方，也就是D处，添加完成后会在地址后面加个 “.” 这是正常的，别手贱把它删了。</p><h3 id="5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图："><a href="#5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图：" class="headerlink" title="5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图："></a>5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_005.jpg" alt></p><h3 id="6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。"><a href="#6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。" class="headerlink" title="6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。"></a>6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_006.jpg" alt></p><h3 id="7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。"><a href="#7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。" class="headerlink" title="7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。"></a>7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;人生如戏，你得先有故事。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;--老李&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2015-null</title>
    <link href="https://oldmee.github.io/2015/02/26/2015-null/"/>
    <id>https://oldmee.github.io/2015/02/26/2015-null/</id>
    <published>2015-02-25T16:21:00.000Z</published>
    <updated>2019-02-26T01:32:07.811Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2014-null</title>
    <link href="https://oldmee.github.io/2014/02/26/2014-null/"/>
    <id>https://oldmee.github.io/2014/02/26/2014-null/</id>
    <published>2014-02-25T16:20:00.000Z</published>
    <updated>2019-02-26T01:32:07.810Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2013-null</title>
    <link href="https://oldmee.github.io/2013/02/26/2013-null/"/>
    <id>https://oldmee.github.io/2013/02/26/2013-null/</id>
    <published>2013-02-25T16:20:00.000Z</published>
    <updated>2019-02-26T01:32:07.810Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>gRPC</title>
    <link href="https://oldmee.github.io/2012/02/26/gRPC/"/>
    <id>https://oldmee.github.io/2012/02/26/gRPC/</id>
    <published>2012-02-25T16:19:00.000Z</published>
    <updated>2019-02-26T04:49:18.437Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</p><p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p><p><img src="/2012/02/26/gRPC/gRPC.jpg" alt></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="基于HTTP-2"><a href="#基于HTTP-2" class="headerlink" title="基于HTTP/2"></a>基于HTTP/2</h4><p>HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。</p><h4 id="IDL使用ProtoBuf"><a href="#IDL使用ProtoBuf" class="headerlink" title="IDL使用ProtoBuf"></a>IDL使用ProtoBuf</h4><p>gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。</p><h4 id="多语言支持（C-C-Python-PHP-Nodejs-C-Objective-C、Golang、Java）"><a href="#多语言支持（C-C-Python-PHP-Nodejs-C-Objective-C、Golang、Java）" class="headerlink" title="多语言支持（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java）"></a>多语言支持（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java）</h4><p>gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。<br>gRPC已经应用在Google的云服务和对外提供的API中，其主要应用场景如下： </p><ul><li>低延迟、高扩展性、分布式的系统 </li><li>同云服务器进行通信的移动应用客户端 </li><li>设计语言独立、高效、精确的新协议 </li><li>便于各方面扩展的分层设计，如认证、负载均衡、日志记录、监控等</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。&lt;/p&gt;
&lt;p&gt;在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，
      
    
    </summary>
    
    
  </entry>
  
</feed>
