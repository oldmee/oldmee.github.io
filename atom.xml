<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>oldmee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://oldmee.github.io/"/>
  <updated>2019-02-26T01:32:07.811Z</updated>
  <id>https://oldmee.github.io/</id>
  
  <author>
    <name>oldmee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>责任链模式</title>
    <link href="https://oldmee.github.io/2019/02/26/chain-of-responsibility-pattern/"/>
    <id>https://oldmee.github.io/2019/02/26/chain-of-responsibility-pattern/</id>
    <published>2019-02-25T16:01:24.000Z</published>
    <updated>2019-02-26T01:32:07.811Z</updated>
    
    <content type="html"><![CDATA[<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。<br><a id="more"></a><br>应用实例： 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p><p>责任链模式demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">AbstractLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">   <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(nextLogger !=<span class="keyword">null</span>)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ConsoleLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"Standard Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ErrorLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FileLogger.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;    </span><br><span class="line">      System.out.println(<span class="string">"File::Logger: "</span> + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ChainPatternDemo.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">      AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">      AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"> </span><br><span class="line">      errorLogger.setNextLogger(fileLogger);</span><br><span class="line">      fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> errorLogger;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, </span><br><span class="line">         <span class="string">"This is an information."</span>);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </span><br><span class="line">         <span class="string">"This is an debug level information."</span>);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </span><br><span class="line">         <span class="string">"This is an error information."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Standard Console::Logger: This is an information.</span><br><span class="line">File::Logger: This is an debug level information.</span><br><span class="line">Standard Console::Logger: This is an debug level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">File::Logger: This is an error information.</span><br><span class="line">Standard Console::Logger: This is an error information.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最高级别的error会被输出三次，最低级别的info只会输出一次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo-bugs-000</title>
    <link href="https://oldmee.github.io/2019/02/25/hexo-bugs-000/"/>
    <id>https://oldmee.github.io/2019/02/25/hexo-bugs-000/</id>
    <published>2019-02-25T12:04:00.000Z</published>
    <updated>2019-02-26T01:32:07.812Z</updated>
    
    <content type="html"><![CDATA[<p>在hexo本地服务器模式下，一旦文章内容过多（具体没测试，可以多放些内容试试），则生成的html在本地就会出问题，没有上一页下一页以及脚标信息，在浏览器里查看网页源代码发现都是些小方格，不知道是什么鬼。但是用户不知道啊，我搞了半天，发现原来是个bug，部署到github上一切正常，真的是脑壳痛……<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在hexo本地服务器模式下，一旦文章内容过多（具体没测试，可以多放些内容试试），则生成的html在本地就会出问题，没有上一页下一页以及脚标信息，在浏览器里查看网页源代码发现都是些小方格，不知道是什么鬼。但是用户不知道啊，我搞了半天，发现原来是个bug，部署到github上一切正常，真的是脑壳痛……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="bugs" scheme="https://oldmee.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>使用 Protocol Buffers 代替 JSON 的五个原因</title>
    <link href="https://oldmee.github.io/2019/02/25/protocol-buffers/"/>
    <id>https://oldmee.github.io/2019/02/25/protocol-buffers/</id>
    <published>2019-02-25T09:53:25.000Z</published>
    <updated>2019-02-26T01:32:07.812Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/25/protocol-buffers/pb.png" alt><br><a id="more"></a></p><h3 id="原因一-模式本身很不错"><a href="#原因一-模式本身很不错" class="headerlink" title="原因一: 模式本身很不错"></a>原因一: 模式本身很不错</h3><p>有一种痛苦的讽刺指向一个事实，我们小心谨慎地在我们的数据库里面编写数据模型，维护各个层次的代码，保持这些数据模型处于控制之中，当我们想要发送数据连接到另一个服务的时候，要求所有的疑虑都要被考虑到。然而，我们往往依靠的是在边界上与我们的系统之间不一致的代码，我们的系统不能强制结构化我们的数据组件，这是如此的重要，编码的语义是你曾经的业务对象，在proto格式中，它足以帮助并保证应用程序之间的信号不会丢失，而界限就在你所创建并执行的业务规则。</p><h3 id="原因二-无偿地向后兼容"><a href="#原因二-无偿地向后兼容" class="headerlink" title="原因二: 无偿地向后兼容"></a>原因二: 无偿地向后兼容</h3><p>被编号的字段在proto的定义中排除了所需的版本检查，这是其中一个被明确表述的动机（为什么这样设计和实现Protocol Buffers）。如同开发者文档中声明的那样，协议被设计成能在一定程度上避免出现像下面这样的“丑陋的代码”，下面的代码用来检测协议的版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (version == <span class="number">3</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt; <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (version == <span class="number">5</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同编号字段一样, 你必须改变编码习惯，朝着能向老版本维护和向后兼容的方向改变。正如在文档中的声明那样，曾经 Protocol Buffers 是这样被介绍的：</p><p>“新的字段可以很容易被引入，并且不需要中间服务去检查数据就能被解析，通过数据不必知道所有的字段。”</p><p>已经部署各种JSON的服务器已经遭受各种与发展模式以及向后兼容的相关问题。我现在深信编号字段能防止错误，并且能在新功能和服务的推出上做到简化。</p><h3 id="原因三-更少的样本代码"><a href="#原因三-更少的样本代码" class="headerlink" title="原因三: 更少的样本代码"></a>原因三: 更少的样本代码</h3><p>除了显式的版本检查和缺乏后续的兼容性，JSON终端在HTTP上的基础服务通常依赖专门的手写样板代码去处理Ruby对象的编码和解码。解析和反解析类常常包含隐藏的业务逻辑，它暴露了手动解析每个新的数据类型的缺陷，当一个类通过Protocol Buffers产生（你一般就不会再去触碰它），它能提供大量相似的方法，还避免了大量头痛的事情。随着模式的发展，你将会用proto产生类（应当承认，一旦你更新他们），你可以把更多的空间留给你所关注的挑战（保持你的应用运行和持续构建产品）。</p><h3 id="原因四-验证和可扩展性"><a href="#原因四-验证和可扩展性" class="headerlink" title="原因四: 验证和可扩展性"></a>原因四: 验证和可扩展性</h3><p>required，optional 和 repeated关键字在Protocol Buffers中的定义是非常强大的。它们允许你去编码，在模式级别，形象化你的数据结构和去实现类怎样工作（每种编程语言处理）的细节。Ruby的protocol_buffers库将会提升异常，例如：如果一个对象实例没有填写必填的字段，你试着去对这样一个对象实例编码，就会提升异常。通过简单地编辑一个新的编号字段的值，你可以把一个字段从required变成optional或者反之亦然。有了这种灵活编码的语义序列化格式，大大增强了其功能。</p><p>因为你还可以嵌入proto，定义内部的其他成员，你也可以拥有通用的Request和Response结构，它还允许其他数据结构的传输并确保传输连接上，它为服务器间通讯实现真正的灵活性和安全的数据传输提供了机会。类似Riak的数据库系统使用Protocol Buffers有巨大的效果——因为有了一些启示，我建议重新审视那些接口。</p><h3 id="原因五：建议的语言互操作性"><a href="#原因五：建议的语言互操作性" class="headerlink" title="原因五：建议的语言互操作性"></a>原因五：建议的语言互操作性</h3><p>因为Protocol Buffers已经被多种语言实现，在你的架构中多语言混合的应用程序之间的互操作性变得更简单。如果你引入了一个新的服务在JAVA或者GO中，甚至和用Node或者Clojure或者Scala实现的后端通讯，你只需简单的把proto文件交给目标语言编写的代码生成器，你将在这些架构之间获得较好的安全和互操作性。平台特定数据类型的细节被目标语言处理，你将更多的关注你的问题的困难部分，而不是匹配字段和数据类型在JSON的编码和解码方案中。</p><p><br></p><h3 id="什么时候更适合使用JSON"><a href="#什么时候更适合使用JSON" class="headerlink" title="什么时候更适合使用JSON?"></a>什么时候更适合使用JSON?</h3><p>有些时候JSON比Protocol Buffers更适合，包括如下的场景：</p><ul><li>你需要或者想让数据对人是可读的</li><li>来自于服务的数据是直接发送到web浏览器</li><li>你的服务端应用程序是用javaScript编写的</li><li>你不准备把数据模型绑定到模式上</li><li>你没有带宽添加另外一个工具到你的军火库</li><li>运行不同类型的网络服务的运营负担过大</li></ul><p>可能还有更多的情况。最后，总之，这是很重要的在心里权衡和不要盲目的选择一项技术。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Protocol Buffers提供了几种相对JSON在内部服务之间在线传输数据的引人注目的优势。并没有完全的替换JSON，特别是服务和web浏览器直接通讯的情况，Protocol Buffers提供了真正的优势不仅在上面概述的方法，在编解码的速度和数据大小上有更多的优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/02/25/protocol-buffers/pb.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>敏感词过滤算法</title>
    <link href="https://oldmee.github.io/2019/02/25/deterministic-finite-automaton/"/>
    <id>https://oldmee.github.io/2019/02/25/deterministic-finite-automaton/</id>
    <published>2019-02-25T07:09:58.000Z</published>
    <updated>2019-02-25T07:27:50.213Z</updated>
    
    <content type="html"><![CDATA[<p>在实现文字过滤的算法中，DFA是唯一比较好的实现算法。DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。<br><a id="more"></a><br>敏感词会被构建成状态加标志位的形式，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 读取敏感词库，将敏感词放入HashSet中，构建一个DFA算法模型：&lt;br&gt; </span></span><br><span class="line"><span class="comment">     * 中 = &#123; </span></span><br><span class="line"><span class="comment">     *      isEnd = 0 </span></span><br><span class="line"><span class="comment">     *      国 = &#123; </span></span><br><span class="line"><span class="comment">     *           isEnd = 1 </span></span><br><span class="line"><span class="comment">     *           人 = &#123;isEnd = 0 </span></span><br><span class="line"><span class="comment">     *                民 = &#123;isEnd = 1&#125; </span></span><br><span class="line"><span class="comment">     *                &#125; </span></span><br><span class="line"><span class="comment">     *           男  = &#123; </span></span><br><span class="line"><span class="comment">     *                  isEnd = 0 </span></span><br><span class="line"><span class="comment">     *                   人 = &#123; </span></span><br><span class="line"><span class="comment">     *                        isEnd = 1 </span></span><br><span class="line"><span class="comment">     *                       &#125; </span></span><br><span class="line"><span class="comment">     *               &#125; </span></span><br><span class="line"><span class="comment">     *           &#125; </span></span><br><span class="line"><span class="comment">     *      &#125; </span></span><br><span class="line"><span class="comment">     *  五 = &#123; </span></span><br><span class="line"><span class="comment">     *      isEnd = 0 </span></span><br><span class="line"><span class="comment">     *      星 = &#123; </span></span><br><span class="line"><span class="comment">     *          isEnd = 0 </span></span><br><span class="line"><span class="comment">     *          红 = &#123; </span></span><br><span class="line"><span class="comment">     *              isEnd = 0 </span></span><br><span class="line"><span class="comment">     *              旗 = &#123; </span></span><br><span class="line"><span class="comment">     *                   isEnd = 1 </span></span><br><span class="line"><span class="comment">     *                  &#125; </span></span><br><span class="line"><span class="comment">     *              &#125; </span></span><br><span class="line"><span class="comment">     *          &#125; </span></span><br><span class="line"><span class="comment">     *      &#125; </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> null  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2019年2月25日 下午3:04:20 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyWordSet  敏感词库 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@version</span> 1.0 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在实现文字过滤的算法中，DFA是唯一比较好的实现算法。DFA即Deterministic Finite Automaton，也就是确定有穷自动机，它是是通过event和当前的state得到下一个state，即event+state=nextstate。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何设计一个高并发系统</title>
    <link href="https://oldmee.github.io/2019/02/25/design-high-concurrency-system/"/>
    <id>https://oldmee.github.io/2019/02/25/design-high-concurrency-system/</id>
    <published>2019-02-25T04:39:57.000Z</published>
    <updated>2019-02-25T07:28:36.364Z</updated>
    
    <content type="html"><![CDATA[<p>有过高并发实践经验的当然最好了，但事实是这很难，除非是这家公司是匹黑马，你刚去的时候用户不多，但是行业发展好，每月几百万用户用户的增长，你不断的踩坑，不断地升级公司的系统架构，现在不太可能实现了，互联网巨头们都已经尘埃落定，所以大部分人基本上也碰不到这些个情况了，但是互联网公司面试要问呐，咋整？<br><a id="more"></a><br>第一类当然是最好的，有过经验的，没有怎么办？退而求其次！你没吃过猪肉还没见过猪跑？把理论玩精了，总比对高并发系统一无所知的人要好的多吧。</p><p>如果你属于第二种情况，试试从下面六个方面来设计一个高并发的系统：</p><ul><li>系统拆分</li><li>缓存</li><li>MQ</li><li>分库分表</li><li>读写分离</li><li>ElasticSearch</li></ul><p><img src="/2019/02/25/design-high-concurrency-system/hc.jpg" alt></p><h3 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h3><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。</p><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。</p><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><blockquote><p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p><footer><strong>--很现实但没什么意义的话</strong></footer></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有过高并发实践经验的当然最好了，但事实是这很难，除非是这家公司是匹黑马，你刚去的时候用户不多，但是行业发展好，每月几百万用户用户的增长，你不断的踩坑，不断地升级公司的系统架构，现在不太可能实现了，互联网巨头们都已经尘埃落定，所以大部分人基本上也碰不到这些个情况了，但是互联网公司面试要问呐，咋整？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图书列表清单</title>
    <link href="https://oldmee.github.io/2019/02/25/book-list/"/>
    <id>https://oldmee.github.io/2019/02/25/book-list/</id>
    <published>2019-02-25T01:29:22.000Z</published>
    <updated>2019-02-25T07:31:04.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>老话说的好：少打王者多读书。</p></blockquote><a id="more"></a><h3 id="阅读清单"><a href="#阅读清单" class="headerlink" title="阅读清单"></a>阅读清单</h3><blockquote><p>2018-12-08<br>第一批次</p></blockquote><ul><li>Java编程思想 第4版</li><li>Head First 设计模式</li><li>深入理解Java虚拟机 JVM高级特性与最佳实践</li><li>Effective Java英文版 第三版</li><li>重构 改善既有代码的设计</li><li>Docker技术入门与实战</li><li>Hadoop权威指南第四版</li><li>Hive编程指南</li><li>Spark快速大数据分析<br><br></li></ul><blockquote><p>2019-01-24<br>第二批次</p></blockquote><ul><li>Effective Java中文版 第三版<br><br></li></ul><blockquote><p>2019-02-20<br>第三批次</p></blockquote><ul><li>RocketMQ技术内幕</li><li>企业私有云建设指南</li><li>ZooKeeper分布式过程协同技术详解</li><li>架构即未来</li><li>架构真经</li><li>Java机器学习</li></ul><p>…未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;老话说的好：少打王者多读书。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>按键精灵编码最佳实践</title>
    <link href="https://oldmee.github.io/2019/02/22/tsy-coding-best-practice/"/>
    <id>https://oldmee.github.io/2019/02/22/tsy-coding-best-practice/</id>
    <published>2019-02-22T08:08:55.000Z</published>
    <updated>2019-02-25T07:30:35.441Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>总来来说就是一次循环就执行一个动作，代码按照界面来操作（到了这个界面应该做什么动作）<br>遵循这个理论下面是具体的执行标准</p></blockquote><a id="more"></a><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><ul><li>用else if代替单条if</li><li>每条else if代表一个界面</li></ul><h3 id="Debug技巧"><a href="#Debug技巧" class="headerlink" title="Debug技巧"></a>Debug技巧</h3><ul><li>刚修改的地方全部注释，缩小范围</li><li>注释一整段if语句，缩小范围</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;总来来说就是一次循环就执行一个动作，代码按照界面来操作（到了这个界面应该做什么动作）&lt;br&gt;遵循这个理论下面是具体的执行标准&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo Admin的使用</title>
    <link href="https://oldmee.github.io/2019/02/22/hexo-use/"/>
    <id>https://oldmee.github.io/2019/02/22/hexo-use/</id>
    <published>2019-02-22T03:22:00.000Z</published>
    <updated>2019-02-25T07:31:21.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这是一个坑"><a href="#这是一个坑" class="headerlink" title="这是一个坑"></a>这是一个坑</h3><p>安装方式我就不说了，就是按照网上说的那样，我主要说一下Deploy中的脚本怎么配置，网上都是类似这种<br><a id="more"></a><br><blockquote><p>./xxxx.sh</p></blockquote></p><p>完了我也傻不拉几的按照这种方式写，后来发现这就是一个脚本，你不用deploy就用命令行运行也是一样的，<br>admin只是一个写markdown的工具，部署只是提供给你一个快捷键罢了，问题是我是Windows，居然也用.sh真是尴尬，改成.bat路径前面也不需要.这也是linux下的写法。deployCommand: ‘hexo-generate.bat’ 就行了。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>每次hexo deploy的时候是不是都要输入github用户名密码？<br>可以这样做</p><p>先配置一个环境变量</p><p><img src="/2019/02/22/hexo-use/home.png" style="margin-left:0px"></p><p>接着在你的用户目录（C:\Users\username）下新建一个叫 _netrc的文件(没有拓展名)<br>编辑这个文件</p><ul><li>machine github.com</li><li>login username</li><li>password password</li></ul><p>设置好这些后，当你再次部署时，就不用输入用户名和密码了。</p><h3 id="tips2"><a href="#tips2" class="headerlink" title="tips2"></a>tips2</h3><p>hexo admin可以配置用户名和密码，密码需要用bcrypt加密，方法如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BCryptDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> 　　<span class="comment">// Hash a password for the first time</span></span><br><span class="line"> 　　　　String password = <span class="string">"testpassword"</span>;</span><br><span class="line">　　　　String hashed = BCrypt.hashpw(password, BCrypt.gensalt());</span><br><span class="line">　　　　System.out.println(hashed);</span><br><span class="line">　　<span class="comment">// gensalt's log_rounds parameter determines the complexity</span></span><br><span class="line">　　<span class="comment">// the work factor is 2**log_rounds, and the default is 10</span></span><br><span class="line">　　String hashed2 = BCrypt.hashpw(password, BCrypt.gensalt(<span class="number">12</span>));</span><br><span class="line"> </span><br><span class="line">　　<span class="comment">// Check that an unencrypted password matches one that has</span></span><br><span class="line">　　<span class="comment">// previously been hashed</span></span><br><span class="line">　　String candidate = <span class="string">"testpassword"</span>;</span><br><span class="line">　　<span class="comment">//String candidate = "wrongtestpassword";</span></span><br><span class="line">　　<span class="keyword">if</span> (BCrypt.checkpw(candidate, hashed))</span><br><span class="line">　　　　System.out.println(<span class="string">"It matches"</span>);</span><br><span class="line">　　<span class="keyword">else</span></span><br><span class="line">　　System.out.println(<span class="string">"It does not match"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;这是一个坑&quot;&gt;&lt;a href=&quot;#这是一个坑&quot; class=&quot;headerlink&quot; title=&quot;这是一个坑&quot;&gt;&lt;/a&gt;这是一个坑&lt;/h3&gt;&lt;p&gt;安装方式我就不说了，就是按照网上说的那样，我主要说一下Deploy中的脚本怎么配置，网上都是类似这种&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo使用" scheme="https://oldmee.github.io/categories/hexo%E4%BD%BF%E7%94%A8/"/>
    
      <category term="hexo admin" scheme="https://oldmee.github.io/categories/hexo%E4%BD%BF%E7%94%A8/hexo-admin/"/>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="博客" scheme="https://oldmee.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Class.forName(&quot;jdbc地址&quot;)到底在干啥</title>
    <link href="https://oldmee.github.io/2019/02/21/mysql-jdbc-driver-function/"/>
    <id>https://oldmee.github.io/2019/02/21/mysql-jdbc-driver-function/</id>
    <published>2019-02-21T04:56:51.000Z</published>
    <updated>2019-03-04T02:33:23.978Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/21/mysql-jdbc-driver-function/mysql.jpg" alt></p><blockquote><p>Talk is cheap，show me the code.</p><footer><strong>--老李</strong></footer></blockquote><a id="more"></a><p>Class.forName(“com.mysql.jdbc.Driver”).newInstance() （Java 9开始newInstance()就已经不赞成使用了）<br>等价于com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();</p><p>Class.forName()的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段（并没有创建新对象）</p><p>所以也可以这么写：com.mysql.jdbc.Driver driver = new com.mysql.jdbc.Driver();</p><p>再看看Driver的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mysql.jdbc</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="comment">// --------------------------------------------- //</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ~ Constructors   </span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据下面三条规则：</p><p>1.当调用一个类的静态变量时，这个类中的静态代码块会执行。【只有静态代码块会执行】</p><p>2.当调用一个 类的静态方法时，这个类中的静态代码块会执行。【只有静态代码块会执行】</p><p>3.当创建一个 类的一个实例时，这个类中的静态代码块、非静态代码块（也叫构造代码块）、创建实例的相应的构造方法都会执行。</p><p>什么？还不明白？</p><p>Class.forName(“com.mysql.jdbc.Driver”);<br>String url = “jdbc:mysql://127.0.0.1/test?useUnicode=true&amp;characterEncoding=utf-8”;<br>String user = “”;<br>String psw = “”;<br>Connection con = DriverManager.getConnection(url,user,psw);<br>Class.forName就是触发static代码块中driver注册到DriverManager的行为，注册完了就可以随便调用了呗。</p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>JDBC还用到了桥接模式，从上面的源码中也很容易理解，数据库厂家安心开发自己的实现，不论是MySQL还是Oracle，通过DriverManager统一进行注册绑定。</p><p>再次理解一下桥接的定义：<br>桥接模式是一种很实用的结构型设计模式，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/02/21/mysql-jdbc-driver-function/mysql.jpg&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Talk is cheap，show me the code.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;--老李&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>我的半生感悟</title>
    <link href="https://oldmee.github.io/2019/02/12/myLife/"/>
    <id>https://oldmee.github.io/2019/02/12/myLife/</id>
    <published>2019-02-12T02:09:00.000Z</published>
    <updated>2019-02-25T11:00:17.218Z</updated>
    
    <content type="html"><![CDATA[<p>学平上了年纪，有很多话要说……<br><a id="more"></a></p><h3 id="中年"><a href="#中年" class="headerlink" title="中年"></a>中年</h3><p>人到中年，有很多想法，也有很多困惑，今天是2019年第一天上班，本来说要昨天做个总结的，但是昨天不知道干嘛了，这个总结也是昨天突然想写的，今天补上吧（其实平时有很多想法都是灵光一闪，想记录着的，但是就是没记）。</p><h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><p>关于家庭，感觉自己就像处在沼泽中在使劲挣扎着，特别不想动，累吗？好像也不是特别累，但就是不想动，又不得不动，给自己下个总结，就是人懒但是现在已经不是一个人了，拖家带口的，还得照顾家庭，所以还得挣扎，但是很不情愿，不情愿也没办法，人活在世总得担责任嘛。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>关于工作，越来越觉得上班是一件性价比极低的事情，在杭州干软件可能年薪二十到三十万就是一个坎了，往上升的途径应该很窄（我说的的大概率情况，开挂的情况不在我说的范围内，因为我就是一个普通的不能再普通的人了，没有幻想着开挂也没有幻想中500万大奖），把我未来的黄金10年重心都放在工作上，想想就可惜，主要是上班工作本质上是拿时间换钱，一种等价交换，时间没了就换不回钱了，不可能有任何积累，没有积累就不会有延续，就像买了瓶汽水喝完就没了，现在满脑子想的是怎么打造一个赚钱的机器，有了机器会轻松很多，虽然需要时不时的去维护一下，但是机器可以传承延续啊，还可以再打造别的机器啊，这样的人生岂不是更有趣一些，当然想法是美好的现实是残酷的，实现这个想法的前提是要有基本的生活保障，突然想人要是不吃饭，光靠光合作用就能活下去多好。</p><h3 id="困惑"><a href="#困惑" class="headerlink" title="困惑"></a>困惑</h3><p>关于困惑，有时候幻想自己已经不再为衣食住行发愁了，我下一步要干啥呢，每天看看电影，世界各地走走？嗯，刚开始可能还新鲜，但是3年以后，5年以后呢，一直这样吗，那多无聊啊，看新闻说郭涛15岁看了终结者后就想拍一部自己的科幻电影，直到今年流浪地球拍出来了，过程当然比较坎坷，但是梦想还是实现了，关于困惑我想说的是我就好像没有啥特别爱好，这是我比较困惑的地方，高晓松说，40不惑就是40岁以后不是没有惑了，而是40岁以后想不明白事就不去想了。我不知道我15岁想要啥，但是我知道我12岁想要啥，为啥是12岁呢，因为一轮生肖都走了一圈，那天家里给买了个大蛋糕还许了愿，当时许的愿就是能有一台打游戏的vcd，因为当时有个广告天天播，又能打游戏又能看电影的一台机器，一想到又能打游戏又能看电影真好，所以就许了这么一个愿望，虽然后来没得到这么一台机器，但是后来上大学我有了电脑啊，大概10年，这也算是愿望实现了吧。</p><h3 id="买房"><a href="#买房" class="headerlink" title="买房"></a>买房</h3><p>关于买房，12岁以后就没有什么特别大的愿望了，甚至大学里都没有什么想法，直到毕业后刚上班有工资了后就是特别想攒一笔10万人民币，当时也没想着拿这10万去干啥干啥，就想着有个目标呗，毕业也快10年了，这10万具体是啥时候攒起来不记得了，只记得15年年底已经到处跑着看房子了，当时也没想着买，就是看看，现在想想15年好像已经有10万了，但是离买的起还差20万，所以只是看看，想得是还得攒2年钱，结果16年9月份G20之后房价像火箭一样，之前看过的房17年10月份再挨个问过去房价都翻倍了，安安心心攒了一年钱，再去看的时候傻眼了，买房一下子提上日程了，看了一圈后，发现要想买房，必须降低自己原来的期望值（原来看的都是100坪左右的，小区环境比较好的），16年底看中的一套105平方2手房，首付加各种费35万拿不出来，最后只好作罢，直到17年3月份36万首付买了80个平的二手，真是一路的心酸，通过这次买房一下打破了固有思维（一直想一步到位然后住一辈子，现在不这么想了，现在想的是多大能力办多大事，而且房子过10年后开始变旧，而新的格局更好的产品也会开发出来），以后就是想着隔10年换一次房（卖旧买新）。 </p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>一些感悟，每个人都有瓶颈，上升到一定阶段后很难突破，就像父辈一样，他们已经完成了他们的使命，而我现在来到了瓶颈地，延续老的思维已经很难上升了，该想着怎么打破现状继续前行，如果打不破，我现在的状态就是下一代的起点。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>关于未来，生活还要继续。。。</p><p>by 花蝴蝶</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学平上了年纪，有很多话要说……&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人生" scheme="https://oldmee.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>旅游之云南</title>
    <link href="https://oldmee.github.io/2018/10/01/travel-yunnan-erhai/"/>
    <id>https://oldmee.github.io/2018/10/01/travel-yunnan-erhai/</id>
    <published>2018-10-01T03:46:00.000Z</published>
    <updated>2019-03-04T02:19:40.077Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十一带着家人去看诗和远方。</p></blockquote><a id="more"></a><video src="1551584899727024.mp4" width="320" height="180" controls="controls"></video>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;十一带着家人去看诗和远方。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="旅游" scheme="https://oldmee.github.io/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="https://oldmee.github.io/2018/09/12/distributed-transaction/"/>
    <id>https://oldmee.github.io/2018/09/12/distributed-transaction/</id>
    <published>2018-09-12T05:58:00.000Z</published>
    <updated>2019-03-02T06:06:03.090Z</updated>
    
    <content type="html"><![CDATA[<p>现在面试，分布式系统成了标配，而分布式系统带来的分布式事务也成了标配了。因为你做系统肯定要用事务吧，如果是分布式系统，肯定要用分布式事务吧。先不说你搞过没有，起码你得明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。<br><a id="more"></a></p><p>分布式事务的实现主要有以下 5 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h3 id="两阶段提交方案-XA方案"><a href="#两阶段提交方案-XA方案" class="headerlink" title="两阶段提交方案/XA方案"></a>两阶段提交方案/XA方案</h3><p>所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说某个系统内部如果出现跨多个库的这么一个操作，是不合规的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求每个服务只能操作自己对应的一个数据库。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><p>如果你要操作别人的服务的库，你必须是通过调用别的服务的接口来实现，绝对不允许交叉访问别人的数据库。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-XA.png" alt></p><h3 id="TCC-方案"><a href="#TCC-方案" class="headerlink" title="TCC 方案"></a>TCC 方案</h3><p>TCC 的全称是：Try、Confirm、Cancel。</p><p>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行锁定或者预留。<br>Confirm 阶段：这个阶段说的是在各个服务中执行实际的操作。<br>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）<br>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个事务回滚实际上是严重依赖于你自己写代码来回滚和补偿了，会造成补偿代码巨大，非常之恶心。</p><p>比如说我们，一般来说跟钱相关的，跟钱打交道的，支付、交易相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码很难维护。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-TCC.png" alt></p><h3 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h3><p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><p>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；<br>接着 A 系统将这个消息发送到 MQ 中去；<br>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息；<br>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；<br>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；<br>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。<br>这个方案说实话最大的问题就在于严重依赖于数据库的消息表来管理事务啥的，会导致如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-local-message-table.png" alt></p><h3 id="可靠消息最终一致性方案"><a href="#可靠消息最终一致性方案" class="headerlink" title="可靠消息最终一致性方案"></a>可靠消息最终一致性方案</h3><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><p>大概的意思就是：</p><p>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；<br>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；<br>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；<br>mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。<br>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。<br>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</p><p><img src="/2018/09/12/distributed-transaction/distributed-transaction-reliable-message.png" alt></p><h3 id="最大努力通知方案"><a href="#最大努力通知方案" class="headerlink" title="最大努力通知方案"></a>最大努力通知方案</h3><p>这个方案的大致意思就是：</p><p>系统 A 本地事务执行完之后，发送个消息到 MQ；<br>这里会有个专门消费 MQ 的最大努力通知服务，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；<br>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在面试，分布式系统成了标配，而分布式系统带来的分布式事务也成了标配了。因为你做系统肯定要用事务吧，如果是分布式系统，肯定要用分布式事务吧。先不说你搞过没有，起码你得明白有哪几种方案，每种方案可能有啥坑？比如 TCC 方案的网络问题、XA 方案的一致性问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="架构" scheme="https://oldmee.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="https://oldmee.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="事务" scheme="https://oldmee.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix 的线程池隔离和信号量隔离</title>
    <link href="https://oldmee.github.io/2018/02/26/Hystrix-isolation/"/>
    <id>https://oldmee.github.io/2018/02/26/Hystrix-isolation/</id>
    <published>2018-02-26T10:38:00.000Z</published>
    <updated>2019-02-26T11:04:42.780Z</updated>
    
    <content type="html"><![CDATA[<p>信号量的隔离：<br> it executes on the calling thread and concurrent requests are limited by the semaphore count.</p><p>每次调用线程，当前请求通过计数信号量进行限制，当信号大于了最大请求数（maxConcurrentRequests）时，进行限制，调用fallback接口快速返回。<br><a id="more"></a></p><p><img src="/2018/02/26/Hystrix-isolation/Hystrix_02.jpg" alt></p><p>最重要的是，信号量的调用是同步的，也就是说，每次调用都得阻塞调用方的线程，直到结果返回。这样就导致了无法对访问做超时（只能依靠调用协议超时，无法主动释放）</p><p>官网对信号量隔离的描述建议</p><p>Generally the only time you should use semaphore isolation for HystrixCommands is when the call is so high volume (hundreds per second, per instance) that the overhead of separate threads is too high; this typically only applies to non-network calls.</p><p>隔离的细粒度太高，数百个实例需要隔离，此时用线程池做隔离开销过大通常这种都是非网络调用的情况下线程池隔离:<br>it executes on a separate thread and concurrent requests are limited by the number of threads in the thread-pool<br>通过每次都开启一个单独线程运行。它的隔离是通过线程池，即每个隔离粒度都是个线程池，互相不干扰</p><p>Commands executed in threads have an extra layer of protection against latencies beyond what network timeouts can offer.<br>线程池隔离方式，等于多了一层的保护措施，可以通过hytrix直接设置超时，超时后直接返回。</p><p><img src="/2018/02/26/Hystrix-isolation/Hystrix_01.jpg" alt></p><p>最后总结对比下：</p><table><thead><tr><th style="text-align:center">隔离方式</th><th style="text-align:center">是否支持超时</th><th style="text-align:center">是否支持熔断</th><th style="text-align:center">隔离原理</th><th style="text-align:center">是否是异步调用</th><th style="text-align:center">资源消耗</th></tr></thead><tbody><tr><td style="text-align:center">线程池隔离</td><td style="text-align:center">支持,可直接返回</td><td style="text-align:center">支持,当线程池到达maxSize后,再请求会触发fallback接口进行熔断</td><td style="text-align:center">每个服务单独用线程池</td><td style="text-align:center">可以是异步,也可以是同步。看调用的方法</td><td style="text-align:center">大,大量线程的上下文切换，容易造成机器负载高</td></tr><tr><td style="text-align:center">信号量隔离</td><td style="text-align:center">不支持,如果阻塞，只能通过调用协议（如:socket超时才能返回）</td><td style="text-align:center">支持，当信号量达到maxConcurrentRequests后。再请求会触发fallback</td><td style="text-align:center">通过信号量的计数器</td><td style="text-align:center">同步调用,不支持异步</td><td style="text-align:center">小,只是个计数器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;信号量的隔离：&lt;br&gt; it executes on the calling thread and concurrent requests are limited by the semaphore count.&lt;/p&gt;
&lt;p&gt;每次调用线程，当前请求通过计数信号量进行限制，当信号大于了最大请求数（maxConcurrentRequests）时，进行限制，调用fallback接口快速返回。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring cloud" scheme="https://oldmee.github.io/tags/spring-cloud/"/>
    
  </entry>
  
  <entry>
    <title>Beanstalk（内存队列）</title>
    <link href="https://oldmee.github.io/2018/02/26/Beanstalk/"/>
    <id>https://oldmee.github.io/2018/02/26/Beanstalk/</id>
    <published>2018-02-25T16:22:00.000Z</published>
    <updated>2019-02-26T09:15:09.314Z</updated>
    
    <content type="html"><![CDATA[<p>Beanstalk是一个高性能、轻量级的、分布式的、内存型的消息队列系统。最初设计的目的是想通过后台异步执行耗时的任务来降低高容量Web应用系统的页面访问延迟。其实Beanstalkd是典型的类Memcached设计，协议和使用方式都是同样的风格。其基本设计思想很简单：高性能离不开异步，异步离不开队列，而内部都是生产者-消费者模式的。<br><a id="more"></a></p><h3 id="Beanstalk介绍："><a href="#Beanstalk介绍：" class="headerlink" title="Beanstalk介绍："></a>Beanstalk介绍：</h3><p>　　那下面开始说beanstalk了。首先说beanstalk其实并不是JMS规范的，也并不严格遵守AMQP协议。有人说Beanstalk之于RabbitMQ，就好比Nginx之于Apache。它更简单，轻量级，高性能，易使用。但是相比kafka，数据处理能力还是有差距，所以我们现在其实在逐渐替代它。但它有些很易用的特殊功能，后面会讲到。</p><p>　　Beanstalk主要包括4个部分。</p><p>　　1&gt; job:一个需要异步处理的任务，需要放在一个tube中。</p><p>　　2&gt; tube:一个有名的任务队列，用来存储统一类型的job，是producer和consumer操作的对象。</p><p>　　3&gt; producer:job的生产者，通过put命令来将一个job放到一个tube中。</p><p>　　4&gt; consumer:job的消费者，通过reserve、release、bury、delete命令来获取job或改变job的状态。</p><p>　　刚才说Beanstalk有一些特殊的好用功能。那就是它支持任务优先级(priority)、延时(delay)、超时重发(time-to-run)和预留(buried)，能够很好的支持分布式的后台任务和定时任务处理。这些特性是和beanstalk工作过程密切相关。</p><p>　　Beanstalk的一个job的生命周期有READY、RESERVED、DELAYED、BURIED四种。</p><p>　　当producer直接put一个job时，job就是READY状态，等待consumer来处理。如果选择延迟put，job就先到DELAYED状态，到指定时间再READY。consumer获取了READY的job，此状态就为RESERVED。这样其他consumer不能再操作此job。当consumer完成该job后，可以选择delete、release或者bury。</p><p>　　delete之后，job不能再获取。release的job可以重新迁移或延迟迁移回READY。bury的job可以被休眠，需要的时候再READY或者delete掉。</p><h3 id="Beanstalk使用场景："><a href="#Beanstalk使用场景：" class="headerlink" title="Beanstalk使用场景："></a>Beanstalk使用场景：</h3><p>　　用作延时队列：比如可以用于如果用户30分钟内不操作，任务关闭。</p><p>　　用作循环队列：用release命令可以循环执行任务，比如可以做负载均衡任务分发。</p><p>　　用作兜底机制：比如一个请求有失败的概率，可以用Beanstalk不断重试，设定超时时间，时间内尝试到成功为止。</p><p>　　用作定时任务：比如可以用于专门的后台任务。</p><p>　　用作异步操作：这是所有消息队列都最常用的，先将任务仍进去，顺序执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Beanstalk是一个高性能、轻量级的、分布式的、内存型的消息队列系统。最初设计的目的是想通过后台异步执行耗时的任务来降低高容量Web应用系统的页面访问延迟。其实Beanstalkd是典型的类Memcached设计，协议和使用方式都是同样的风格。其基本设计思想很简单：高性能离不开异步，异步离不开队列，而内部都是生产者-消费者模式的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty</title>
    <link href="https://oldmee.github.io/2017/03/01/netty/"/>
    <id>https://oldmee.github.io/2017/03/01/netty/</id>
    <published>2017-03-01T08:47:00.000Z</published>
    <updated>2019-03-01T10:45:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/03/01/netty/netty.jpg" alt><br>Netty 是互联网中间件领域使用最广泛最核心的网络通信框架。上图中可以看到，几乎所有互联网中间件或者大数据领域均离不开 Netty。<br><a id="more"></a></p><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>NIO编程模型中，新来一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责，那么他是怎么做到的？我们用一幅图来对比一下IO与NIO</p><p><img src="/2017/03/01/netty/netty01.jpg" alt><br><img src="/2017/03/01/netty/netty02.jpg" alt></p><p>IO模型中，一个连接来了，会创建一个线程，对应一个while死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读，因此，很多个while死循环都白白浪费掉了，因为读不出啥数据。</p><p>而在NIO模型中，他把这么多while死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个while死循环就能监测1w个连接是否有数据可读的呢？</p><p>这就是NIO模型中selector的作用，一条连接来了之后，现在不创建一个while死循环去监听是否有数据可读了，而是直接把这条连接注册到selector上，然后，通过检查这个selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的例子说明IO与NIO的区别。</p><p>在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一共有100个小朋友，有两种方案可以解决小朋友上厕所的问题：</p><p>每个小朋友配一个老师。每个老师隔段时间询问小朋友是否要上厕所，如果要上，就领他去厕所，100个小朋友就需要100个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去上，这就是IO模型，一个连接对应一个线程。<br>所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所的小朋友批量领到厕所，这就是NIO模型，所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到一个线程，然后批量轮询。</p><p>这就是NIO模型解决线程资源受限的方案，实际开发过程中，我们会开多个线程，每个线程都管理着一批连接，相对于IO模型中一个线程管理一条连接，消耗的线程资源大幅减少</p><h3 id="JDK-NIO的缺点"><a href="#JDK-NIO的缺点" class="headerlink" title="JDK NIO的缺点"></a>JDK NIO的缺点</h3><ul><li>JDK的NIO编程需要了解很多的概念，编程复杂，对NIO入门非常不友好，编程模型不友好，ByteBuffer的api简直反人类</li><li>对NIO编程来说，一个比较合适的线程模型能充分发挥它的优势，而JDK没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现</li><li>JDK的NIO底层由epoll实现，该实现饱受诟病的空轮训bug会导致cpu飙升100%</li><li>项目庞大之后，自行实现的NIO很容易出现各类bug，维护成本较高，上面这一坨代码我都不能保证没有bug</li></ul><h3 id="netty的优点"><a href="#netty的优点" class="headerlink" title="netty的优点"></a>netty的优点</h3><ul><li>设计优雅，适用于各种传输类型的统一 API 阻塞和非阻塞 Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池；真正的无连接数据报套接字支持（自 3.1 起）。</li><li>使用方便，详细记录的 Javadoc，用户指南和示例；没有其他依赖项，JDK 5（Netty 3.x）或 6（Netty 4.x）就足够了。</li><li>高性能，吞吐量更高，延迟更低；减少资源消耗；最小化不必要的内存复制。</li><li>安全，完整的 SSL/TLS 和 StartTLS 支持。</li><li>社区活跃，不断更新，社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。</li></ul><h3 id="使用Netty而不使用JDK原生NIO的原因"><a href="#使用Netty而不使用JDK原生NIO的原因" class="headerlink" title="使用Netty而不使用JDK原生NIO的原因"></a>使用Netty而不使用JDK原生NIO的原因</h3><ul><li>使用JDK自带的NIO需要了解太多的概念，编程复杂，一不小心bug横飞</li><li>Netty底层IO模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从NIO模型变身为IO模型</li><li>Netty自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑</li><li>Netty解决了JDK的很多包括空轮询在内的bug</li><li>Netty底层对线程，selector做了很多细小的优化，精心设计的reactor线程模型做到非常高效的并发处理</li><li>自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手</li><li>Netty社区活跃，遇到问题随时邮件列表或者issue</li><li>Netty已经历各大rpc框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大</li></ul><h3 id="Netty的helloWorld"><a href="#Netty的helloWorld" class="headerlink" title="Netty的helloWorld"></a>Netty的helloWorld</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.1.6.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boos = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        NioEventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        serverBootstrap</span><br><span class="line">                .group(boos, worker)</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> SimpleChannelInboundHandler&lt;String&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> </span>&#123;</span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .bind(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        Channel channel = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>).channel();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> Date() + <span class="string">": hello world!"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/03/01/netty/netty.jpg&quot; alt&gt;&lt;br&gt;Netty 是互联网中间件领域使用最广泛最核心的网络通信框架。上图中可以看到，几乎所有互联网中间件或者大数据领域均离不开 Netty。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="netty" scheme="https://oldmee.github.io/tags/netty/"/>
    
      <category term="框架" scheme="https://oldmee.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring REST Docs 介绍</title>
    <link href="https://oldmee.github.io/2017/02/26/Spring-REST-Docs/"/>
    <id>https://oldmee.github.io/2017/02/26/Spring-REST-Docs/</id>
    <published>2017-02-25T16:22:00.000Z</published>
    <updated>2019-02-26T06:49:42.237Z</updated>
    
    <content type="html"><![CDATA[<p>Spring REST Docs 是一个为 Spring 项目生成 API 文档的框架，它通过在单元测试中额外添加 API 信息描述，从而自动生成对应的文档片段。<br><a id="more"></a><br>本文会以一个最简单的示例介绍如何在一个 Spring Boot 应用中使用 Spring REST Docs，并在最后与目前最常见的 SpringFox 进行一些对比，分别介绍其特点和优劣。</p><h3 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h3><p>首先需要一个 Spring Boot 项目，并通过 MockMvc 编写一些简单的测试。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="number">200</span>, String.format(<span class="string">"Hello %s!"</span>, name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面代码中提供了一个最简单的 Controller，其接收请求参数中的name属性，并返回一个包含code和msg的 Result对象。</p><p>接下来需要为其编写一个测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">"/hello"</span>).param(<span class="string">"name"</span>, <span class="string">"ScienJus"</span>))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(jsonPath(<span class="string">"msg"</span>, <span class="string">"Hello ScienJus!"</span>).exists())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里使用了 JUnit5 和 Spring 的 MockMvc 编写 API 测试，只是简单的请求这个 API 并校验返回值。</p><p>完成以上工作，就可以开始通过修改测试代码，为这个 API 自动生成相关的描述文档了。</p><h3 id="配置-Spring-REST-Docs"><a href="#配置-Spring-REST-Docs" class="headerlink" title="配置 Spring REST Docs"></a>配置 Spring REST Docs</h3><p>当使用 MockMvc 时，只需要添加 spring-restdocs-mockmvc 依赖：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><br>之后，需要修改测试代码，添加对应的文档支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebMvcTest</span></span><br><span class="line"><span class="meta">@ExtendWith</span>(&#123;RestDocumentationExtension.class, SpringExtension.class&#125;) &lt;<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span> &lt;<span class="number">2</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">(WebApplicationContext webApplicationContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                      RestDocumentationContextProvider restDocumentation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)</span><br><span class="line">                .apply(documentationConfiguration(restDocumentation))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">"/hello"</span>).param(<span class="string">"name"</span>, <span class="string">"ScienJus"</span>))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andExpect(jsonPath(<span class="string">"msg"</span>, <span class="string">"Hello ScienJus!"</span>).exists())</span><br><span class="line">                .andDo(document(<span class="string">"hello"</span>)); &lt;<span class="number">3</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 @ExtendWith 中增加 RestDocumentationExtension（JUnit5 的 Extension 相当于 JUnit4 中的 Rule）。<br>将 MockMvc 由直接注入改为手动构建，增加 documentationConfiguration(restDocumentation) 配置。<br>在执行测试的最后，调用 andDo(document(“hello”)) 给测试调用所生成的文档命名。</p><h3 id="构建文档"><a href="#构建文档" class="headerlink" title="构建文档"></a>构建文档</h3><p>完成配置后，运行 mvn clean package 进行构建，当测试运行成功后查看 target/generated-snippets 下出现的一系列 adoc 文档：<br><img src="/2017/02/26/Spring-REST-Docs/spring-rest-docs-00.jpg" alt></p><p>其中 curl/httpie-request.adoc 记录了测试请求通过 curl 和 httpie 的调用方式， http-request/response.adoc 记录了测试请求和返回的 raw 信息，request/response-body.adoc 记录了请求和返回的 Payload。</p><p>不过这些都只是一个个文档片段，还需要将其拼凑到一起才能成为一份完整的 API 文档，框架本身不提供直接生成完整文档的功能，所以需要编写一个文档主页并引入这些自动生成的文档片段。</p><p>默认的文档主页可以放在 src/main/asciidoc/index.adoc 中，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">= Learn Spring REST Docs</span><br><span class="line">:toc: left</span><br><span class="line"></span><br><span class="line">Learn how to use Spring REST Docs based on Spring Boot2 and JUnit5.</span><br><span class="line"></span><br><span class="line">== /hello: Say <span class="string">"Hello World!"</span></span><br><span class="line"></span><br><span class="line">operation::hello[]</span><br></pre></td></tr></table></figure></p><p>其中最重要的一行是 operation::hello[]，它表示将 hello 下的所有片段都引入进入，或者也可以指定 operation::hello[snippets=’curl-request,http-request,http-response’] 的方式只引入部分代码片段。</p><p>编写好文档主页后，需要使用 asciidoctor-maven-plugin 使其可以在打包时与片段整合起来，并生成最终的 HTML 文件：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.3&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;generate-docs&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;prepare-package&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;process-asciidoc&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;backend&gt;html&lt;/backend&gt;</span><br><span class="line">                &lt;doctype&gt;book&lt;/doctype&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-restdocs-asciidoctor&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p><p>此时再次运行 mvn clean package 之后，可以看到 target/generated-docs 下生成了最终的网页，其最终效果如下图所示。<br><img src="/2017/02/26/Spring-REST-Docs/spring-rest-docs.jpg" alt><br>至此，最简单的请求文档便构建完成了。</p><h4 id="和-SpringFox-的对比"><a href="#和-SpringFox-的对比" class="headerlink" title="和 SpringFox 的对比"></a>和 SpringFox 的对比</h4><p>相较于传统且更流行的 SpringFox（Swagger），Spring REST Docs 的实现方式相当新颖，而且有着鲜明的区别，那么不妨在此列举一下两者的区别以及优劣，以便更好的根据实际需求和使用场景选择最合适的工具。</p><p>首先，两者最大的区别就在于根本定位，SpringFox 的定位是和应用一起启动的在线文档，文档的浏览者可以很简单的填写表单并发起一个真实的请求，而 Spring REST Docs 更倾向于导出一份离线文档作为展示，并配合 curl、httpie 这种工具请求真实部署的服务。</p><p>其次，SpringFox 最大的特点是使用简单，只需要在源码中增加一些描述性的注解即可完成整份文档，而使用 Spring REST Docs 的前提条件是需要在项目中对 API 进行单元测试，并且要保证测试是可以稳定执行的，这对于很多团队来说无疑增加了很高的门槛。</p><p>但是对于已经有完整单元测试的团队来说，增加额外的文档描述几乎和 SpringFox 一样简单，并且还能完整的去除源码依赖。除此之外，依靠测试本身也正是 Spring REST Docs 的最大亮点：</p><p>首先，每一次测试都是一个真实的请求（不追究 MockMvc 具体实现细节），它所对应的请求和返回都是真实的，可以轻松将其记录下来作为 Demo 展示。而 SpringFox 只是对 Controller 层的方法进行了扫描，却无法感知 Interceptor、MethodArgumentResolver 这类中间件的存在，只能通过一些全局配置进行额外的描述。</p><p>其次，每一次测试也都是一个独立的请求，使得 Spring REST Docs 可以描述同一个 API 在不同请求参数中返回的不同结果的场景（例如成功或是各种失败情况），而 SpringFox 只能描述单一的方法签名和返回值 Model，却无法描述其具体可能出现的场景。</p><p>最后，错误的文档比没有文档还要糟糕，所以 Spring REST Docs 不仅仅是做 API 文档化，同时也是在做 API 契约化，如果 API 的实现修改破坏了已有的测试，哪怕仅仅是字段定义，都会导致测试的失败。这可以督促 API 的制定者保证对外提供的契约，也可以让 API 的使用者更加放心。</p><p>所以相比之下，如果一个技术氛围良好，对服务严格负责，且愿意尝试 API 单元测试和契约测试的团队来说，我更推荐使用 Spring REST Docs，而如果只是在已有的服务上增加描述性的文档，SpringFox 会是性价比更高的选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring REST Docs 是一个为 Spring 项目生成 API 文档的框架，它通过在单元测试中额外添加 API 信息描述，从而自动生成对应的文档片段。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>七牛云融合CDN到底怎么配置</title>
    <link href="https://oldmee.github.io/2016/12/08/qiniu-CDN/"/>
    <id>https://oldmee.github.io/2016/12/08/qiniu-CDN/</id>
    <published>2016-12-08T09:58:00.000Z</published>
    <updated>2019-03-02T06:10:16.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生如戏，你得先有故事。</p><footer><strong>--老李</strong></footer></blockquote><a id="more"></a><p>由于来年头一个月公司产品接入了一个旅游项目，为了保证系统的稳定性，必须要对现有架构进行改进以应对大流量的冲击。</p><p>那么问题来了？怎么改？</p><p>首先，我得清楚项目目前的瓶颈在什么地方，项目的日常应用场景是怎样的？</p><p>我先来分析一下我们项目的情况：我们这个项目主要是应用AR技术进行娱乐，原理就是利用高通家的Vuforia SDK实现边缘识别来叠加模型，哪些图像要被识别是需要提前传到高通的服务器上的，服务器会生成几个Vuforia专用的识别文件（dataset），再将识别文件整合到项目中，识别到了需要调用什么模型自己配置就可以了。<br>我主管后台，围绕着Vuforia的结构开发了一套程序进行后台文件的管理，简单的说就是有哪些识别图，识别到了会出现什么效果等等。</p><p>上面是后台的应用场景，再来看看用户端的使用场景，用户端只有移动端，Android和IOS，原理是这样：启动我们的app会先加载一段配置文件（json），主要就是让手机知道，哪些图片可以被识别（这里多说一句，因为识别图片会越来越多，所以启动速度也越来越慢，我特意研究了一下国内easyAR的SDK，他们可以即时更换识别图片，而且不用传到服务器等待生成识别文件这么复杂，但是搞AR的那哥们在高通的Vuforia花了太多时间，多少还是有点经验的，万一换个SDK，没啥优势了，嗯……很恐怖，所以老技术人一般不会轻易尝试新的技术，因为自己占领的优势会立马失去，哎……），长时间的加载等待后进入了主界面。我们根据识别图开发了很多周边产品，比如说识别图印在T恤上，做成钥匙扣，等等等等，总之就是各种识别图附着在各种实物上，听到这里我们的商业模式也应运而生，没错，卖实物赚钱，app免费下！<br>用手机扫描识别图app就会认识并给出下载提示，什么？又要下载？解释一下，这次下的是模型，也就是识别到了之后展示的效果，一个3D模型，unity开发的，这里也是一个影响用户体验的地方，用户好不容易下载了我们的app，之后好不容易进入了主界面，完了还得下载，你是用户你糟不糟心，糟！现在还是改版后的，有分类的，第一版是所有的模型都在一个包下，也就是说，进入主界面后要一次性下载所有的模型，那酸爽，简直了~<br>改版后的对模型进行了分类，这样下载时间能短一点，但是换到另外一个分类又得重新下载（用户已经气晕在地上了……），下载后模型会缓存在手机本地，现在即使用户断网了也依然可以愉快的玩耍了。</p><p>写了一大段介绍app的应用场景，瓶颈已经很明显了，首先就是app启动的时候从服务拉取的那一段配置文件，其次就是下载的模型文件。怎么解决就很简单了，配置文件上缓存，因为读取的都是相同的内容，典型的读多写少的场景，模型文件是大文件，静态的，全部上CDN，这样，瓶颈就解决了，至少目前是解决了，应对来年的那个流量没有任何问题了。</p><p>好了，进入正题，缓存就不细讲了，不是本文的主角，来聊聊CDN吧。</p><p>CDN（Content Delivery Network）内容分发网络，就是厂家在地球的一些地方部署了服务器，作为仓库存放用户的文件，用户访问CDN服务器的时候会经过一个路由算法找到离访问者最近的一台服务器，这样就能实现快速访问，而且可以极大地减少自己服务器的压力，你想想啊，如果你的服务器在昆明，东北的用户访问你的服务器是不是要慢多了？因为距离远了嘛。CDN通过流量来收费，很合理，用的多，花的多，用的少，花的也少。</p><p>最后来看看CDN配置的具体步骤吧：</p><h3 id="1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图："><a href="#1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图：" class="headerlink" title="1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图："></a>1、先创建一个空间，以后你的乱七八糟的文件都会存放在这个空间里，如下图：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_001.jpg" alt></p><h3 id="2、在融合CDN中创建加速域名列表，如下图："><a href="#2、在融合CDN中创建加速域名列表，如下图：" class="headerlink" title="2、在融合CDN中创建加速域名列表，如下图："></a>2、在融合CDN中创建加速域名列表，如下图：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_002.jpg" alt><br>加速域名随便写一个二级域名：a.b.com.cn  c.d.com  等等，写在这里，然后最后的源站配置选择第一个“七牛云存储”，并选择你刚才创建的那个空间。</p><h3 id="3、完成后你会看到这样的信息："><a href="#3、完成后你会看到这样的信息：" class="headerlink" title="3、完成后你会看到这样的信息："></a>3、完成后你会看到这样的信息：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_003.jpg" alt><br><img src="/2016/12/08/qiniu-CDN/CDN_003_1.jpg" alt></p><h3 id="4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢："><a href="#4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢：" class="headerlink" title="4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢："></a>4、找到你们的域名管理页面，域名管理有很多网站，阿里云，万网等等，按照下图配置，肯定不一样，请照葫芦画瓢：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_004.jpg" alt><br>主机记录写加速域名里你填写的那个二级域名的前段，请看上图B中介绍，主要就是把七牛给你的CNAME填写到正确的地方，也就是D处，添加完成后会在地址后面加个 “.” 这是正常的，别手贱把它删了。</p><h3 id="5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图："><a href="#5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图：" class="headerlink" title="5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图："></a>5、等待个十几二十分钟，状态就会变成“成功”（也就是第三部中的图片），下面是七牛存储空间的测试域名，如下图：</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_005.jpg" alt></p><h3 id="6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。"><a href="#6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。" class="headerlink" title="6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。"></a>6、找到存储管理中的“镜像存储”，镜像源填写你们网站的网址，有端口的把端口也加上，下面的镜像空间是你创建的那个存储空间的名字。</h3><p><img src="/2016/12/08/qiniu-CDN/CDN_006.jpg" alt></p><h3 id="7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。"><a href="#7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。" class="headerlink" title="7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。"></a>7、访问第五步中的那个测试域名或者你最开始写的加速域名，幸运的话会跳转到你配置的镜像源也就是你公司的网址页面去，多访问一些页面，你会在七牛存储空间的内容管理中看到多了一些文件，其实这就是你们公司网址上的资源文件，七牛第一次访问的时候根据镜像源去你们公司抓取并存放在七牛云你创建的存储空间里，之后再次访问就直接在七牛里面拿了，大大的降低了你们公司服务器的压力。</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;人生如戏，你得先有故事。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;--老李&lt;/strong&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper之ZAB协议</title>
    <link href="https://oldmee.github.io/2016/02/21/zookeeper-ZAP/"/>
    <id>https://oldmee.github.io/2016/02/21/zookeeper-ZAP/</id>
    <published>2016-02-21T02:13:00.000Z</published>
    <updated>2019-03-04T09:20:01.671Z</updated>
    
    <content type="html"><![CDATA[<p>既然说到了zookeeper，那就再来聊聊ZAB（Zookeeper Atomic Broadcast）协议吧。<br><a id="more"></a></p><h3 id="ZAB协议介绍"><a href="#ZAB协议介绍" class="headerlink" title="ZAB协议介绍"></a>ZAB协议介绍</h3><p>ZAB协议包含两种基本模式，分别是：</p><ol><li>崩溃恢复之数据恢复 </li><li>消息广播之原子广播 </li></ol><p>当整个集群正在启动时，或者当leader节点出现网络中断、崩溃等情况时，ZAB协议就会进入恢复模式并选举产生新的leader，当leader服务器选举出来后，并且集群中有过半的机器和该leader节点完成数据同步后（同步指的是数据同步，用来保证集群中过半的机器能够和leader服务器的数据状态保持一致），ZAB协议就会退出恢复模式。 </p><p>当集群中已经有过半的Follower节点完成了和Leader状态同步以后，那么整个集群就进入了消息广播模式。这个时候，在Leader节点正常工作时，启动一台新的服务器加入到集群，那这个服务器会直接进入数据恢复模式，和leader节点进行数据同步。同步完成后即可正常对外提供非事务请求的处理。</p><h3 id="消息广播（原子广播）"><a href="#消息广播（原子广播）" class="headerlink" title="消息广播（原子广播）"></a>消息广播（原子广播）</h3><p>消息广播实际上是一个简化版的2PC（二阶段提交协议）提交过程。 </p><p>过程如下： </p><ol><li>leader接收到消息请求后，将消息赋予一个全局唯一的64位自增id，叫：zxid，通过zxid的大小比较就可以实现因果有序这个特征。 </li><li>leader为每个follower准备了一个FIFO队列（通过TCP协议来实现，以实现全局有序这一个特点）将带有zxid的消息作为一个提案（proposal）分发给所有的 follower。 </li><li>当follower接收到proposal，先把proposal写到磁盘，写入成功以后再向leader回复一个ack。 </li><li>当leader接收到合法数量（超过半数节点）的ack后，leader就会向这些follower发送commit命令，同时会在本地执行该消息。 </li><li>当follower收到消息的commit命令以后，会提交该消息。</li></ol><h3 id="崩溃恢复（数据恢复）"><a href="#崩溃恢复（数据恢复）" class="headerlink" title="崩溃恢复（数据恢复）"></a>崩溃恢复（数据恢复）</h3><p>ZAB协议的这个基于原子广播协议的消息广播过程，在正常情况下是没有任何问题的，但是一旦Leader节点崩溃，或者由于网络问题导致Leader服务器失去了过半的Follower节点的联系（leader失去与过半follower节点联系，可能是leader节点和 follower节点之间产生了网络分区，那么此时的leader不再是合法的leader了），那么就会进入到崩溃恢复模式。在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的Leader。<br>为了使leader挂了后系统能正常工作，需要解决以下两个问题： </p><h4 id="已经被处理的消息不能丢失"><a href="#已经被处理的消息不能丢失" class="headerlink" title="已经被处理的消息不能丢失"></a><code>已经被处理的消息不能丢失</code></h4><ul><li>当leader收到合法数量follower的ack后，就向各个follower广播commit命令，同时也会在本地执行commit并向连接的客户端返回「成功」。但是如果各个follower在收到commit命令前leader就挂了，导致剩下的服务器并没有执行到这条消息。 </li><li>leader对事务消息发起commit操作，该消息在follower1上执行了，但是follower2还没有收到commit，leader就已经挂了，而实际上客户端已经收到该事务消息处理成功的回执了。所以在zab协议下需要保证所有机器都要执行这个事务消息，必须满足已经被处理的消息不能丢失。 </li></ul><h4 id="被丢弃的消息不能再次出现"><a href="#被丢弃的消息不能再次出现" class="headerlink" title="被丢弃的消息不能再次出现"></a><code>被丢弃的消息不能再次出现</code></h4><ul><li>当leader接收到消息请求生成proposal后就挂了，其他follower并没有收到此proposal，因此经过恢复模式重新选了leader后，这条消息是被跳过的。 此时，之前挂了的leader重新启动并注册成了follower，他保留了被跳过消息的proposal状态，与整个系统的状态是不一致的，需要将其删除。（leader都换代了，所以以前leader的proposal失效了）</li></ul><h3 id="针对崩溃恢复的两种情况分析"><a href="#针对崩溃恢复的两种情况分析" class="headerlink" title="针对崩溃恢复的两种情况分析"></a>针对崩溃恢复的两种情况分析</h3><p>ZAB协议需要满足上面两种情况，就必须要设计一个leader选举算法，能够确保已经被leader提交的事务Proposal能够提交、同时丢弃已经被跳过的事务Proposal。 </p><h4 id="针对第一个要求："><a href="#针对第一个要求：" class="headerlink" title="针对第一个要求："></a>针对第一个要求：</h4><ul><li>如果leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID 最大）的事务Proposal，那么就可以保证这个新选举出来的leader一定具有已经提交的提案。因为所有提案被commit之前必须有超过半数的follower ack，即必须有超过半数节点的服务器的事务日志上有该提案的proposal，因此只要有合法数量的节点正常工作，就必然有一个节点保存了所有被commit消息的proposal状态。 </li></ul><h4 id="另外一个："><a href="#另外一个：" class="headerlink" title="另外一个："></a>另外一个：</h4><ul><li>zxid是64位，高32位是epoch编号，每经过一次Leader选举产生一个新的leader，新的leader会将epoch号+1，低32位是消息计数器，每接收到一条消息这个值+1，新leader选举后这个值重置为0。这样设计的好处在于老的leader挂了以后重启，它不会被选举为leader，因此此时它的zxid肯定小于当前新的leader。当老的leader作为follower接入新的leader后，新的leader会让它将所有的拥有旧的epoch号的未被commit的proposal清除。</li></ul><h3 id="关于ZXID"><a href="#关于ZXID" class="headerlink" title="关于ZXID"></a>关于ZXID</h3><p>zxid，也就是事务id，为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid，实际中zxid是一个64位的数字，它高32位是epoch（ZAB协议通过epoch编号来区分Leader周期变化的策略）用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch=（原来的epoch+1），标识当前属于那个leader的统治时期。低32位用于递增计数。</p><h3 id="测试epoch的变化"><a href="#测试epoch的变化" class="headerlink" title="测试epoch的变化"></a>测试epoch的变化</h3><p>要测试epoch的变化可以做一个简单的实验： </p><ol><li>启动一个zookeeper集群。 </li><li><p>在 /tmp/zookeeper/VERSION-2 路径下会看到一个currentEpoch文件，文件中显示的是当前的epoch。<br><img src="/2016/02/21/zookeeper-ZAP/ZAB_00.png" alt></p></li><li><p>把leader节点停机，这个时候再看currentEpoch会发生变化。 随着每次选举新的leader，epoch都会发生变化。 </p><ol><li><p>先找到leader节点<br><img src="/2016/02/21/zookeeper-ZAP/ZAB_01.png" alt></p></li><li><p>停止leader节点的服务<br><img src="/2016/02/21/zookeeper-ZAP/ZAB_02.png" alt></p></li><li><p>查看当前epoch号的变化（epoch号由原来的6变为7）<br><img src="/2016/02/21/zookeeper-ZAP/ZAB_03.png" alt></p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然说到了zookeeper，那就再来聊聊ZAB（Zookeeper Atomic Broadcast）协议吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>zookeeper之ZAB协议</title>
    <link href="https://oldmee.github.io/2016/02/21/zookeeper-ZAB/"/>
    <id>https://oldmee.github.io/2016/02/21/zookeeper-ZAB/</id>
    <published>2016-02-21T02:13:00.000Z</published>
    <updated>2019-03-04T09:56:07.305Z</updated>
    
    <content type="html"><![CDATA[<p>既然说到了zookeeper，那就再来聊聊ZAB（Zookeeper Atomic Broadcast）协议吧。<br><a id="more"></a></p><h3 id="ZAB协议介绍"><a href="#ZAB协议介绍" class="headerlink" title="ZAB协议介绍"></a>ZAB协议介绍</h3><p>ZAB协议包含两种基本模式，分别是：</p><ol><li>崩溃恢复之数据恢复 </li><li>消息广播之原子广播 </li></ol><p>当整个集群正在启动时，或者当leader节点出现网络中断、崩溃等情况时，ZAB协议就会进入恢复模式并选举产生新的leader，当leader服务器选举出来后，并且集群中有过半的机器和该leader节点完成数据同步后（同步指的是数据同步，用来保证集群中过半的机器能够和leader服务器的数据状态保持一致），ZAB协议就会退出恢复模式。 </p><p>当集群中已经有过半的Follower节点完成了和Leader状态同步以后，那么整个集群就进入了消息广播模式。这个时候，在Leader节点正常工作时，启动一台新的服务器加入到集群，那这个服务器会直接进入数据恢复模式，和leader节点进行数据同步。同步完成后即可正常对外提供非事务请求的处理。</p><h3 id="消息广播（原子广播）"><a href="#消息广播（原子广播）" class="headerlink" title="消息广播（原子广播）"></a>消息广播（原子广播）</h3><p>消息广播实际上是一个简化版的2PC（二阶段提交协议）提交过程。 </p><p>过程如下： </p><ol><li>leader接收到消息请求后，将消息赋予一个全局唯一的64位自增id，叫：zxid，通过zxid的大小比较就可以实现因果有序这个特征。 </li><li>leader为每个follower准备了一个FIFO队列（通过TCP协议来实现，以实现全局有序这一个特点）将带有zxid的消息作为一个提案（proposal）分发给所有的 follower。 </li><li>当follower接收到proposal，先把proposal写到磁盘，写入成功以后再向leader回复一个ack。 </li><li>当leader接收到合法数量（超过半数节点）的ack后，leader就会向这些follower发送commit命令，同时会在本地执行该消息。 </li><li>当follower收到消息的commit命令以后，会提交该消息。</li></ol><h3 id="崩溃恢复（数据恢复）"><a href="#崩溃恢复（数据恢复）" class="headerlink" title="崩溃恢复（数据恢复）"></a>崩溃恢复（数据恢复）</h3><p>ZAB协议的这个基于原子广播协议的消息广播过程，在正常情况下是没有任何问题的，但是一旦Leader节点崩溃，或者由于网络问题导致Leader服务器失去了过半的Follower节点的联系（leader失去与过半follower节点联系，可能是leader节点和 follower节点之间产生了网络分区，那么此时的leader不再是合法的leader了），那么就会进入到崩溃恢复模式。在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的Leader。<br>为了使leader挂了后系统能正常工作，需要解决以下两个问题： </p><h4 id="已经被处理的消息不能丢失"><a href="#已经被处理的消息不能丢失" class="headerlink" title="已经被处理的消息不能丢失"></a><code>已经被处理的消息不能丢失</code></h4><ul><li>当leader收到合法数量follower的ack后，就向各个follower广播commit命令，同时也会在本地执行commit并向连接的客户端返回「成功」。但是如果各个follower在收到commit命令前leader就挂了，导致剩下的服务器并没有执行到这条消息。 </li><li>leader对事务消息发起commit操作，该消息在follower1上执行了，但是follower2还没有收到commit，leader就已经挂了，而实际上客户端已经收到该事务消息处理成功的回执了。所以在zab协议下需要保证所有机器都要执行这个事务消息，必须满足已经被处理的消息不能丢失。 </li></ul><h4 id="被丢弃的消息不能再次出现"><a href="#被丢弃的消息不能再次出现" class="headerlink" title="被丢弃的消息不能再次出现"></a><code>被丢弃的消息不能再次出现</code></h4><ul><li>当leader接收到消息请求生成proposal后就挂了，其他follower并没有收到此proposal，因此经过恢复模式重新选了leader后，这条消息是被跳过的。 此时，之前挂了的leader重新启动并注册成了follower，他保留了被跳过消息的proposal状态，与整个系统的状态是不一致的，需要将其删除。（leader都换代了，所以以前leader的proposal失效了）</li></ul><h3 id="针对崩溃恢复的两种情况分析"><a href="#针对崩溃恢复的两种情况分析" class="headerlink" title="针对崩溃恢复的两种情况分析"></a>针对崩溃恢复的两种情况分析</h3><p>ZAB协议需要满足上面两种情况，就必须要设计一个leader选举算法，能够确保已经被leader提交的事务Proposal能够提交、同时丢弃已经被跳过的事务Proposal。 </p><h4 id="针对第一个要求："><a href="#针对第一个要求：" class="headerlink" title="针对第一个要求："></a>针对第一个要求：</h4><ul><li>如果leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID 最大）的事务Proposal，那么就可以保证这个新选举出来的leader一定具有已经提交的提案。因为所有提案被commit之前必须有超过半数的follower ack，即必须有超过半数节点的服务器的事务日志上有该提案的proposal，因此只要有合法数量的节点正常工作，就必然有一个节点保存了所有被commit消息的proposal状态。 </li></ul><h4 id="另外一个："><a href="#另外一个：" class="headerlink" title="另外一个："></a>另外一个：</h4><ul><li>zxid是64位，高32位是epoch编号，每经过一次Leader选举产生一个新的leader，新的leader会将epoch号+1，低32位是消息计数器，每接收到一条消息这个值+1，新leader选举后这个值重置为0。这样设计的好处在于老的leader挂了以后重启，它不会被选举为leader，因此此时它的zxid肯定小于当前新的leader。当老的leader作为follower接入新的leader后，新的leader会让它将所有的拥有旧的epoch号的未被commit的proposal清除。</li></ul><h3 id="关于ZXID"><a href="#关于ZXID" class="headerlink" title="关于ZXID"></a>关于ZXID</h3><p>zxid，也就是事务id，为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid，实际中zxid是一个64位的数字，它高32位是epoch（ZAB协议通过epoch编号来区分Leader周期变化的策略）用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch=（原来的epoch+1），标识当前属于那个leader的统治时期。低32位用于递增计数。</p><h3 id="测试epoch的变化"><a href="#测试epoch的变化" class="headerlink" title="测试epoch的变化"></a>测试epoch的变化</h3><p>要测试epoch的变化可以做一个简单的实验： </p><ol><li>启动一个zookeeper集群。 </li><li><p>在 /tmp/zookeeper/VERSION-2 路径下会看到一个currentEpoch文件，文件中显示的是当前的epoch。<br><img src="/2016/02/21/zookeeper-ZAB/ZAB_00.png" alt></p></li><li><p>把leader节点停机，这个时候再看currentEpoch会发生变化。 随着每次选举新的leader，epoch都会发生变化。 </p><ol><li><p>先找到leader节点<br><img src="/2016/02/21/zookeeper-ZAB/ZAB_01.png" alt></p></li><li><p>停止leader节点的服务<br><img src="/2016/02/21/zookeeper-ZAB/ZAB_02.png" alt></p></li><li><p>查看当前epoch号的变化（epoch号由原来的6变为7）<br><img src="/2016/02/21/zookeeper-ZAB/ZAB_03.png" alt></p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;既然说到了zookeeper，那就再来聊聊ZAB（Zookeeper Atomic Broadcast）协议吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookeeper" scheme="https://oldmee.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>一秒钟搞懂分布式锁</title>
    <link href="https://oldmee.github.io/2016/02/21/zookeeper/"/>
    <id>https://oldmee.github.io/2016/02/21/zookeeper/</id>
    <published>2016-02-21T02:12:00.000Z</published>
    <updated>2019-03-04T09:04:23.038Z</updated>
    
    <content type="html"><![CDATA[<p>怎么可能一秒钟，起码也得一分钟吧~<br><a id="more"></a></p><h3 id="分布式锁获取思路"><a href="#分布式锁获取思路" class="headerlink" title="分布式锁获取思路"></a>分布式锁获取思路</h3><p>a、在zookeeper指定节点（locker）下创建临时顺序节点。</p><p>b、客户端调用createNode方法在locker下创建临时顺序节点，然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。</p><p>c、客户端获取到所有的子节点path之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。</p><p>d、如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。</p><p>e、之后，如果这个被关注的节点被删除了（释放锁的时候会删除该节点），则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;怎么可能一秒钟，起码也得一分钟吧~&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://oldmee.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
